{"pages":[{"title":"關於","text":"","link":"/about/"}],"posts":[{"title":"Linux Kernel: ARRAY_SIZE()","text":"通常我們在 C 語言中取得陣列的元數個數可以透過下列的方式來計算： 1234#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))int arr[10];int arr_size = ARRAY_SIZE(arr); 但如同 Jserv 大大在 這篇文章 中所提到：ARRAY_SIZE() 這樣的 macro 其實是陷阱重重… 因為 macro 本身沒辦法做型態檢查，只是單純的將值帶入並展開，而在 C 中我們常常會將指標和陣列混著使用。因此若是我們將指向該陣列的指標傳入，就會得到錯誤的計算結果。 如下面的程式： 1234567891011121314#include &amp;lt;stdio.h&amp;gt;#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))int main(void){ int a[10]; int *a_ptr = a; printf(&quot;%d\\n&quot;, ARRAY_SIZE(a)); printf(&quot;%d\\n&quot;, ARRAY_SIZE(a_ptr)); return 0;} 若傳入陣列 a，則結果會正確顯示 size 大小為 10，但若傳入的是指向陣列 a 的指標 a_ptr，則因為指標的在 32 位元作業系統上大小為 4 bytes (4 / 4) 的結果則會變成 1，而並不是我們所要的答案 10。 當然只要我們小心使用，這樣的問題其實是可以避免的\u001b。但我們常常有可能會將陣列透過指標的方式傳入某個 function 中，這樣的情況下我們就有可能會將指標誤用成陣列傳入 ARRAY_SIZE() 而得到錯誤的結果。當程式成長到一定的複雜度後，類似的bug就很有可能被忽略。 因此 Linux 在定義 ARRAY_SIZE() 時除了透過上述的方式來取得陣列元數個數外，還另外加上了型態檢查，以確保使用者所傳入的參數必須為陣列而非指標 (Linux中的 ARRAY_SIZE() 是被定義在：include/linux/kernel.h)，其定義如下： 1#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr)) 其中在最尾端額外加了 __must_be_array() 的回傳值。__must_be_array() 這個 macro 是用來判斷所傳入的參數是否為一陣列 (定義在：include/linux/compiler-gcc.h)，其定義如下： 12/* &amp;a[0] degrades to a pointer: a different type from an array */#define __must_be_array(a) BUILD_BUG_ON_ZERO(__same_type((a), &amp;(a)[0])) 在這邊 __must_be_array() 對所傳入的參數 a 做了一次降級 (degrade)，並將其當作第二個參數傳入 __same_type() 這個 macro。在這邊做降級的目的就是為了讓陣列轉成一個指標，但若所傳入的參數 a 是個不應傳入的指標，則這樣的降級轉換後的結果仍會是相同的原指標。 __same_type() 的回傳值則會傳入 BUILD_BUG_ON_ZERO()(BUILD_BUG_ON_ZERO() 的說明可以參考：BUILD_BUG_ON_ZERO() / BUILD_BUG_ON_NULL())。 __same_type() 的定義則如下 (定義在：include/linux/compiler.h)： 1234/* Are two types/vars the same type (ignoring qualifiers)? */#ifndef __same_type# define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))#endif 在這邊我們可以看到 __same_type() 呼叫了 GCC 的 built-in function：__builtin_types_compatible_p()：(__builtin_types_compatible_p() 的定義可以參考 GCC manual 的說明)；__builtin_types_compatible_p() 的定義可以參考 GCC manual 的說明 You can use the built-in function __builtin_types_compatible_p to determine whether two types are the same.This built-in function returns 1 if the unqualified versions of the types type1 and type2 (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions.This built-in function ignores top level qualifiers (e.g., const, volatile). For example, int is equivalent to const int.The type int[] and int[5] are compatible. On the other hand, int and char * are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, short * is not similar to short **. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible.An enum type is not considered to be compatible with another enum type even if both are compatible with the same integer type; this is what the C standard specifies. For example, enum {foo, bar} is not similar to enum {hot, dog}.You would typically use this function in code whose execution varies depending on the arguments’ types. For example: 12345678910111213#define foo(x) \\ ({ \\ typeof (x) tmp = (x); \\ if (__builtin_types_compatible_p (typeof (x), long double)) \\ tmp = foo_long_double (tmp); \\ else if (__builtin_types_compatible_p (typeof (x), double)) \\ tmp = foo_double (tmp); \\ else if (__builtin_types_compatible_p (typeof (x), float)) \\ tmp = foo_float (tmp); \\ else \\ abort (); \\ tmp; \\ }) Note: This construct is only available for C. 也就是說 __builtin_types_compatible_p() 會檢查所傳入的型態：type_1 和 type_2 是否相同： 若 type_1 和 type_2 的型態相同，則會回傳 1。 若 type_1 和 type_2 的型態不同，則會回傳 0。 此外，為了取得參數的型態，這邊還另外用到了另一個 GCC 的 extension：typeof()。typeof() 可以取得所傳入參數的型態，因此我們可以透過 typeof() 來宣告一個與所傳入參數一模一樣的新變數：(typeof() 的定義同樣可以參考 GCC manual 的說明) 1234567891011121314#include &amp;lt;stdio.h&amp;gt; #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0])) int main(void){ int a[10]; typeof(a) b; printf(&quot;%d\\n&quot;, ARRAY_SIZE(a)); printf(&quot;%d\\n&quot;, ARRAY_SIZE(b)); return 0;} 在此我們宣告一個與陣列 a 型態一模一樣的陣列 b，因此透過 ARRAY_SIZE() 計算陣列元數個數的結果都會是 10。 回到 __same_type()： 透過 __builtin_types_compatible_p() 和 typeof()，我們就可以知道所傳入的兩個參數型態是否相同： 如果相同 (傳入 ARRAY_SIZE() 的參數為一不應傳入的指標)，則 __builtin_types_compatible_p() 就會回傳 1，再傳入 BUILD_BUG_ON_ZERO() 後就會造成編譯錯誤。 但如果不同 (傳入 ARRAY_SIZE() 的參數為一正確的陣列)，則 __builtin_types_compatible_p() 就會回傳 0，再傳入 BUILD_BUG_ON_ZERO() 後得到的結果為 0，加回 ARRAY_SIZE() 後並不會影響其原先結果。 透過這樣的方式，我們便可在 compile-time 的時候就發現所傳入 ARRAY_SIZE() 的參數是否為一錯誤的指標，並可在編譯時期加以修正… 此外 Jserv 大大 那篇文章 下面的回應也有人提出了其他不同的 作法。雖然其原意是為了要避免使用 GCC extension 的，但最後發現原來 typeof() 也是一個 GCC extension，不過作法同樣可以作為參考。 Extra References: sizeof 在語言層面的陷阱","link":"/Linux-Kernel-ARRAY-SIZE/"},{"title":"Linux Kernel: BUILD_BUG_ON_ZERO() / BUILD_BUG_ON_NULL()","text":"之前在 trace Linux Kernel source codes 時發現了兩個很特別的 macros：BUILD_BUG_ON_ZERO() 和 BUILD_BUG_ON_NULL()(定義在：include/linux/kernel.h) 它們的定義如下： 123456/* Force a compilation error if condition is true, but also produce a result (of value 0 and type size_t), so the expression can be used e.g. in a structure initializer (or where-ever else comma expressions aren&apos;t permitted). */#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); })) 其中 e 是我們所傳入的判斷式，若判斷式為 true，則會造成 compile error。如此我們便可透過這個 macro 來判斷是否某些錯誤/不應發生的情況 (判斷式) 是否會發生，若會發生則可在 compile-time 的時候就顯示錯誤訊息。 一開始看不太懂這個 macro 的意義，上網查了資料後發現在 Stackoverflow 上有人做了很詳細的解釋：What is 「:-!!」 in C code? 1sizeof(struct { int:-!!(e); }) 如同 Stackoverflow 上所解釋，這段 codes 可以拆成下面幾個片段來分析： !!(e) 將所傳入的 e 做兩次 negative，如此可以確保只要 e 不為 0 結果一定為 1，e 為 0 結果仍為 0。 -!!(e) 將剛剛的結果乘上 (-1)，因此只要 e 不為 0 結果就會是 -1，e 為 0 結果仍為 0。 struct { int:-1!!(e) } 宣告一個 structure，包含一個 int，這邊用到了 C 語言 bit-fields的技巧。 根據維基百科 bit-fields 的定義： A bit field is a common idiom used in computer programming to compactly store multiple logical values as a short series of bits where each of the single bits can be addressed separately. 也就是說我們可以將資料以 bit 的形式儲存在某一個資料型態中，舉例來說： 12345struct { unsigned char a : 1; unsigned char b : 3; unsigned char c : 2;} flags; 就宣告了 3 個 bit-fields：a, b, c。這 3 個 bit-fields 會包在同一個 unsigned char 資料型態 (8-bits) 中，其中 a 佔了 1 個bit，b 佔了 3 個 bits，c 佔了 2 個 bits，但整個 flags structure 還是會佔 8 個 bits (1 byte)，即使 bit-fields 並沒有佔滿整個 8 bits 空間。 此外，bit-fields 是無法使用 sizeof() 取得其 size 的，因此以下的 codes 將會產生：error: ‘sizeof’ applied to a bit-field 的錯誤訊息： 1printf(&quot;%d\\n&quot;, sizeof(flags.a)); 回到原本的 struct { int:-1!!(e) }，我們可以得知： 若 e 不為 0，則 struct { int:-!!(e); } 會展開成：struct { int:-1; }。也就是會宣告一個 structure，包含 1 個佔 int (32 bits) 中，-1 個 bits 的 anonymous bit-field。當然，絕對不會有佔 -1 個 bits 的 bit-field 存在，因此這樣會導致在編譯時產生：error: negative width in bit-field ‘‘ 的錯誤訊息。 若 e 為 0，則 struct { int:-1!!(e); } 會展開成：struct { int:0; }。也就是宣告一個 structure，包含 1 個佔 int (32 bits) 中，0 個 bits 的 anonymous bit-field。0 個 bits 的 bit-field 並不會造成編譯出錯，事實上，宣告成 0 個 bits 的 bit-field 通常是用來將資料強制對齊至下一個word邊界 (force alignment at the next word boundary)，而且不會佔任何的空間!!。 透過這樣的方式，只要傳入 BUILD_BUG_ON_ZERO(e) 的 e 不為 0，其就會造成 編譯出錯。 若傳入 BUILD_BUG_ON_ZERO(e) 的 e 為 0，則只會宣告一個 不佔任何空間的 structure。經過 sizeof() 計算後回傳 0 的值。 同樣的 BUILD_BUG_ON_NULL() 則是將上述的結果轉成 void，因此只要傳入 BUILD_BUG_ON_NULL(e) 的 e 不為NULL，其就會造成 編譯出錯。 若傳入 BUILD_BUG_ON_NULL(e) 的 e 為 NULL，則只會宣告一個 不佔任何空間的 structure。經過 sizeof() 計算後仍為 0，再轉成一個指向位址 0 的 void。 而 Stackoverflow 上的回答也有提到，為何不直接使用 assert() 就好了？其答案也很清楚： These macros implement a compile-time test, while assert() is a run-time test. 也就是說這樣的機制是可以在 compile-time 的時候就發現問題，而 assert() 則必須等到 run-time 的時候才能發現問題。不過也就是因為 BUILD_BUG_ON_ZERO() 和 BUILD_BUG_ON_NULL() 只能使用在 compile-time 就可以找到 bug 的情況下，因此若是判斷式中有任何必須等到 run-time 才能得知的結果，就會造成錯誤： 12345678910111213#include &amp;lt;stdio.h&amp;gt; #define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); })) int main(void){ int a = 2; BUILD_BUG_ON_ZERO(a == 2); BUILD_BUG_ON_ZERO(2 == 2); return 0;} 第一次呼叫 BUILD_BUG_ON_ZERO() 由於傳入的判斷式中包含 run-time 才會得知其值的 a，因此會造成 compiler 錯誤的判斷，產生錯誤訊息：error: bit-field ‘‘ width not an integer constant。但第二次呼叫 BUILD_BUG_ON_ZERO() 由於判斷式展開後皆可在 compile-time 的時候得知其結果，因此就不會產生錯誤訊息。 所以在使用 BUILD_BUG_ON_ZERO() 或是 BUILD_BUG_ON_NULL() 的時候還是要注意其使用時機….. 不得不說Linux內用了許多非常漂亮的技巧… 不但可以在 compile-time 的時候就將錯誤顯示出來，若判斷式 (錯誤/不應發生的情況) 不成立亦不會造成任何空間的浪費!!(BUILD_BUG_ON_ZERO() 的實際用法可以參考 Linux Kernel: ARRAY_SIZE() 一文)","link":"/Linux-Kernel-BUILD-BUG-ON-ZERO-BUILD-BUG-ON-NULL/"},{"title":"QEMU Decodetree 語法介紹 (Part 1.)","text":"⚠️ 本文所使用的 QEMU 版本為：v4.2.0 QEMU 在 decode 指令的時候，需要呼叫各平台所定義的 instruction decoders 來解析指令。如在 ARM 平台下，就定義了：disas_arm_insn()、disas_thumb_insn() 及 disas_thumb2_insn() 等來分別負責 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。 而 Decodetree 則是由 Bastian Koppelmann 於 2017 年在 porting RISC-V QEMU 的時候所提出來的機制 (詳見：討論串 1、討論串 2)。主因是過往的 instruction decoders (如：ARM) 都是採用一大包的 switch-case 來做判斷。不僅難閱讀，也難以維護。 因此 Bastian Koppelmann 就提出了 Decodetree 的機制，開發者只需要透過 Decodetree 的語法定義各個指令的格式，便可交由 Decodetree 來動態生成對應包含 switch-case 的 instruction decoder .c 檔。 Decodetree 特別適合像 RISC-V 這種具有固定指令格式的 ISA[1]。 因為各欄位都在固定的位置，(如 RISC-V 的 opcode 都是固定在 bits[6..0] 的位置)，各指令可重複使用的定義相較於其他的 ISA 來得多。 Decodetree 其實是由 Python script (./scripts/decodetree.py) 所撰寫的。其規格說明文件可以參考：./docs/devel/decodetree.rst，裡面有詳細定義了其語法的格式。QEMU 在編譯時，會呼叫 Decodetree，根據各平台所定義的 decode 檔，動態生成對應的 decoder。 如 RISC-V 的 instruction decoders 就是被定義在：./target/riscv/*.decode 中。其 Makefile.obj 就有如下的宣告： 12345678910111213...DECODETREE = $(SRC_PATH)/scripts/decodetree.pydecode32-y = $(SRC_PATH)/target/riscv/insn32.decodedecode32-$(TARGET_RISCV64) += $(SRC_PATH)/target/riscv/insn32-64.decode...target/riscv/decode_insn32.inc.c: $(decode32-y) $(DECODETREE) $(call quiet-command, \\ $(PYTHON) $(DECODETREE) -o $@ --static-decode decode_insn32 \\ $(decode32-y), &quot;GEN&quot;, $(TARGET_DIR)$@) (實際參數說明請見 decodetree 參數) Decodetree 的語法共分為：Fields、Argument Sets、Formats、Patterns、Pattern Groups 五部分。本文將介紹如何透過 Decodetree 的語法，來動態生成一個指令的 decoder。 Fields Field 定義如何取出一指令中，各欄位 (eg: rd, rs1, rs2, imm) 的值。 12field_def := &apos;%&apos; identifier ( unnamed_field )* ( !function=identifier )?unnamed_field := number &apos;:&apos; ( &apos;s&apos; ) number 其語法由 % 開頭，隨後緊接著一個 identifier 及零個或多個 unamed_field，並可再加上可選的 !function。 identifier 可由開發者自訂，如：rd、imm… 等。 unamed_field 定義了該欄位的所在位元。第一個數字定義了該欄位的 least-significant bit position，第二個數字則定義了該欄位的位元長度。另外可加上可選的 s 字元來標明在取出該欄位後，是否需要做 sign-extended。 Eg：%rd 7:5 代表 rd 佔了指令中 bits 7 ~ bits 11 的位置 (insn[11:7])，共 5 bits。 !function 定義在擷取出該欄位的值後，所會再呼叫的 function。 Field (32-bits 指令) 最後會生成對應的 extract32() 及 sextract32() 程式碼[2]，以用來取得指令中各欄位的值： Examples Input Generated code %disp 0:s16 sextract(i, 0, 16) %imm9 16:6 10:3 extract(i, 16, 6) &lt;&lt; 3 | extract(i, 10, 3) %disp12 0:s1 1:1 2:10 sextract(i, 0, 1) &lt;&lt; 11 | extract(i, 1, 1) &lt;&lt; 10 | extract(i, 2, 10) %shimm8 5:s8 13:1 !function=expand_shimm8 expand_shimm8(sextract(i, 5, 8) &lt;&lt; 1 | extract(i, 13, 1)) 以 RISC-V 的 U-type 指令為例： 其中，imm 佔 insn[31:12]，rd 佔 insn[11:7]，且 imm 需要做 sign-extended 後 左移 12 位 (20-bit immediate is shifted left by 12 bits to form U immediates)。因此，如果我們要定義 RISC-V 的 U-type 指令，則可以宣告成： 12%rd 7:5%imm_u 12:s20 !function=ex_shift_12 最後會生成如下的程式碼： 12345static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn){ a-&gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-&gt;rd = extract32(insn, 7, 5);} (P.S. static void decode_insn32_extract_u() 是由 Format 定義所生成的，而 arg_u *a 則是由 Argument Set 定義所生成的，將會在後面的部分再做說明) 可以看到： 12a-&gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20));a-&gt;rd = extract32(insn, 7, 5); a-&gt;imm 是由 insn[31:12] 所取得並做 sign-extended，且會再呼叫 ex_shift_12() 來 左移 12 個 bits。 P.S. RISC-V 的 ex_shift_12() 是透過定義在./target/riscv/translate.c 中 EX_SH 這個 macro 所展開的： 12345678910#define EX_SH(amount) \\ static int ex_shift_##amount(DisasContext *ctx, int imm) \\ { \\ return imm &lt;&lt; amount; \\ }EX_SH(1)EX_SH(2)EX_SH(3)EX_SH(4)EX_SH(12) a-&gt;rd 是由 insn[11:7] 所取得。 此外，在 Decodetree 的 spec. 中也有提到，我們可以透過只定義 !function 來直接呼叫該 function。在這種情況下，只有 DisasContext 會被傳入該 function。 One may use !function with zero unnamed_fields. This case is called a parameter, and the named function is only passed the DisasContext and returns an integral value extracted from there. 如 ARM Thumb ./target/arm/t16.decode 就有定義： 12# Set S if the instruction is outside of an IT block.%s !function=t16_setflags 12345678static void disas_t16_extract_addsub_2i(DisasContext *ctx, arg_s_rri_rot *a, uint16_t insn){ a-&gt;imm = extract32(insn, 6, 3); a-&gt;rn = extract32(insn, 3, 3); a-&gt;rd = extract32(insn, 0, 3); a-&gt;s = t16_setflags(ctx); // 呼叫 t16_setflags()，並傳入 DisasContext a-&gt;rot = 0;} 未包含任何 unnamed_fields 或 !function 的 Field 會被視為錯誤。 A field with no unnamed_fields and no !function is in error. Argument Sets Argument Set 定義用來保存從指令中所擷取出來各欄位的值。 12args_def := &apos;&amp;&apos; identifier ( args_elt )+ ( !extern )?args_elt := identifier 其語法由 &amp; 開頭，隨後緊接著一個或多個的 identifier ，並可再加上可選的 !extern 。 identifier 可由開發者自訂，如：regs、loadstore… 等。 !extern 則表示是否在其他地方已經由其他的 decoder 定義過。如果加上的話，就不會再次生成對應的 argument set struct。 Examples 1&amp;ampreg3 ra rb rc 會生成以下的 argument set struct： 12345typedef struct { int ra; int rb; int rc;} arg_reg3; 1&amp;loadstore reg base offset 則會生成以下的 argument set struct： 12345typedef struct { int base; int offset; int reg;} arg_loadstore; 因此，以剛剛的 RISC-V U-type 指令為例，我們需要從指令中擷取 imm 及 rd 欄位的值，可以宣告其 argument set 如下： 1&amp;u imm rd 最後會生成以下的 argument set struct： 1234typedef struct { int imm; int rd;} arg_u; 此 argument set struct 會被傳入由 Format 定義所生成的 extract function： 12345static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn){ a-&gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-&gt;rd = extract32(insn, 7, 5);} 所傳入的arg_u 會保存從指令中擷取出的 imm 及 rd 欄位的值，待後續使用。 Formats Format 定義了指令的格式 (如 RISC-V 中的 R、I、S、B、U、J-type)，並會生成對應的 decode function。 123456fmt_def := &apos;@&apos; identifier ( fmt_elt )+fmt_elt := fixedbit_elt | field_elt | field_ref | args_reffixedbit_elt := [01.-]+field_elt := identifier &apos;:&apos; &apos;s&apos;? numberfield_ref := &apos;%&apos; identifier | identifier &apos;=&apos; &apos;%&apos; identifierargs_ref := &apos;&amp;&apos; identifier 其語法由 @ 開頭，隨後緊接著一個 identifier 及一個以上的 fmt_elt。 identifier 可由開發者自訂，如：opr、opi… 等。 fmt_elt 則可以採用以下不同的語法： fixedbit_elt 包含一個或多個 0、1、.、-，每一個代表指令中的 1 個 bit。 . 代表該 bit 可以用 0 或是 1 來表示。 - 代表該 bit 完全被忽略。 field_elt 可以用 Field 的語法來宣告。 Eg：ra:5、rb:5、lit:8 field_ref 有下列兩種格式 (以下範例參考上文所定義之 Field)： &apos;%&apos; identifier：直接參考一個被定義過的 Field。 如：%rd，會生成： 1a-&gt;rd = extract32(insn, 7, 5); identifier &apos;=&apos; &apos;%&apos; identifier：直接參考一個被定義過的 Field，但透過第一個 identifier 來重新命名其所對應的 argument 名稱。此方式可以用來指定不同的 argument 名稱來參考至同一個 Field。 如：my_rd=%rd，會生成： 1a-&gt;my_rd = extract32(insn, 7, 5); // rd 被重新命名為 my_rd args_ref 指定所傳入 decode function 的 Argument Set。若沒有指定 args_ref 的話，Decodetree 會根據 field_elt 或 field_ref 自動生成一個 Argument Set。此外，一個 Format 最多只能包含一個 args_ref。 當 fixedbit_elt 或 field_ref 被定義時，該 Foramt 的所有的 bits 都必須被定義 (可透過 fixedbit_elt 或 . 來定義各個 bits，空格會被忽略)。 Examples 1@opi ...... ra:5 lit:8 1 ....... rc:5 定義了 op1 這個 Format，其中： insn[31:26] 可為 0 或 1。 insn[25:21] 為 ra。 insn[20:13] 為 lit。 insn[12] 固定為 1。 insn[11:5] 可為 0 或 1。 insn[4:0] 為 rc。 此 Format 會生成以下的 decode function： 12345678910111213typedef struct { int lit; int ra; int rc;} arg_decode_insn320;static void decode_insn32_extract_opi(DisasContext *ctx, arg_decode_insn320 *a, uint32_t insn){ a-&gt;ra = extract32(insn, 21, 5); a-&gt;lit = extract32(insn, 13, 8); a-&gt;rc = extract32(insn, 0, 5);} 由於我們沒有指定 args_ref，因此 Decodetree 根據了 field_elt 的定義，自動生成了 arg_decode_insn320 這個 Argument Set。 以 RISC-V I-type 指令為例： 1234567891011# Fields:%rs1 15:5%rd 7:5# immediates:%imm_i 20:s12# Argment sets:&amp;i imm rs1 rd@i ........ ........ ........ ........ &amp;i imm=%imm_i %rs1 %rd 定義了 i 這個 Format，其中： insn[31:20] 為 imm，且為 sign-extended。 insn[19:5] 為 rs1。 insn[11:7] 為 rd。 此外，我們可以看到： 此 Format 指定了 Argument Set：&amp;i。 &amp;i 中必須包含所有有用到的 arguments (也就是：imm、rs1 及 rd) imm 是透過重新命名的方式來參考 %imm_i 這個 Field。 此範例會生成以下的 decode function： 12345678910111213typedef struct { int imm; int rd; int rs1;} arg_i;static void decode_insn32extract_i(DisasContext *ctx, arg_i *a, uint32_t insn){ a-&gt;imm = sextract32(insn, 20, 12); // imm_i 被重新命名為 imm a-&gt;rs1 = extract32(insn, 15, 5); a-&gt;rd = extract32(insn, 7, 5);} 相比於第一個範例，由於這次我們有指定 args_ref：&amp;i，因此對應的 arg_i 會被傳入 decode function。 回到先前的 RISC-V U-type 指令，我們可以如同 I-type 指令定義其格式： 12345678910# Fields:%rd 7:5# immediates:%imm_u 12:s20 !function=ex_shift_12# Argument sets:&amp;u imm rd@u .................... ..... ....... &amp;u imm=%imm_u %rd 定義了 u 這個 Format，其中： insn[31:12] 為 imm，且為 sign-extended。 insn[11:7] 為 rd。 會生成以下的 decode function： 1234567891011typedef struct { int imm; int rd;} arg_u;static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn){ a-&gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-&gt;rd = extract32(insn, 7, 5);} 我們可以看到： 此 Format 指定了 Argument Set：&amp;u。 &amp;u 中必須包含所有有用到的 arguments (也就是：imm、rd) imm 是透過重新命名的方式來參考 %imm_u 這個 Field。 以上就是 Decodetree 的 Fields、Argument Sets 及 Formats 語法的簡介。剩下的 Patterns 及 Pattern Groups 就留到 Part 2. 再做介紹。 decodetree 參數 --translate：translator function 的 prefix，預設為 trans。一旦指定後，translator function 的 scope 就不會再是 static。 --decode：decode function 的 prefix，預設為 decode，且 scope 為 static。一旦指定後，decode function 的 scope 就不會再是 static。 --static-decode：如同 --decode，不過 decode function 的 scope 仍維持為 static。 -o / --output：指定生成的 decoder .c 檔路徑。 -w / --insnwidth：指令長度，eg：32 or 16，預設為 32。 --varinsnwidth：指令為不定長度。 最後一個參數為輸入的 decode 檔路徑。 執行範例： 12./decodetree.py -o target/riscv/decode_insn16.inc.c --static-decode decode_insn16 \\ -w 16 ./insn16.decode 如 Thumb 指令：./target/arm/t32.decode 及 ./target/arm/t16.decode。 ARM 其實在 Decodetree 引進後，也有部分的 instructions 改採用 Decodetree 來動態生成對應的 instruction decoders ↩︎ extract32() 及 sextract32() 被定義在 include/qemu/bitops.h： 123456789101112131415161718/** * extract32: * @value: the value to extract the bit field from * @start: the lowest bit in the bit field (numbered from 0) * @length: the length of the bit field * * Extract from the 32 bit input @value the bit field specified by the * @start and @length parameters, and return it. The bit field must * lie entirely within the 32 bit word. It is valid to request that * all 32 bits are returned (ie @length 32 and @start 0). * * Returns: the value of the bit field extracted from the input value. */static inline uint32_t extract32(uint32_t value, int start, int length){ assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 32 - start); return (value &gt;&gt; start) &amp; (~0U &gt;&gt; (32 - length));} 123456789101112131415161718192021222324/** * sextract32: * @value: the value to extract the bit field from * @start: the lowest bit in the bit field (numbered from 0) * @length: the length of the bit field * * Extract from the 32 bit input @value the bit field specified by the * @start and @length parameters, and return it, sign extended to * an int32_t (ie with the most significant bit of the field propagated * to all the upper bits of the return value). The bit field must lie * entirely within the 32 bit word. It is valid to request that * all 32 bits are returned (ie @length 32 and @start 0). * * Returns: the sign extended value of the bit field extracted from the * input value. */static inline int32_t sextract32(uint32_t value, int start, int length){ assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 32 - start); /* Note that this implementation relies on right shift of signed * integers being an arithmetic shift. */ return ((int32_t)(value &lt;&lt; (32 - length - start))) &gt;&gt; (32 - length);} ↩︎","link":"/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/"},{"title":"QEMU Decodetree 語法介紹 (Part 2.)","text":"⚠️ 本文所使用的 QEMU 版本為：v4.2.0 延續 Part 1. 一文，本文將繼續介紹 Decodetree 中的 Patterns 及 Pattern Groups 語法。 Patterns Pattern 實際定義了一個指令的 decode 方式。Decodetree 會根據 Patterns 的定義，來動態產生出對應的 switch-case decode 判斷式。 1234pat_def := identifier ( pat_elt )+pat_elt := fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | const_eltfmt_ref := &apos;@&apos; identifierconst_elt := identifier &apos;=&apos; number 其語法由使用者所定義的 identifier，隨後緊接著一個以上的 pat_elt。 identifier 可由開發者自訂，如：addl_r、addli … 等。 pat_elt 則可以採用以下不同的語法： fixedbit_elt 與在 Format 中 fixedbit_elt 的定義相同。 field_elt 與在 Format 中 field_elt 的定義相同。 field_ref 與在 Format 中 field_ref 的定義相同。 args_ref 與在 Format 中 args_ref 的定義相同。 fmt_ref 直接參考一個被定義過的 Format。 const_elt 可以直接指定某一個 argument 的值。 由於 Pattern 實際定義了一個指令的 decode 方式，因此所有的 bits 及 arguments (如果有參考 args_ref 的話) 都必須明確的被定義，如果在搭配了所有的 pat_elt 後還有未定義的 bits 或是 arguments 的話，Decodetree 便會報錯。 此外，Pattern 所產生出來的 decoder，最後還會呼叫對應的 translator function。 translator function 需開發者自行定義。 Examples 1addl_i 010000 ..... ..... .... 0000000 ..... @opi 定義了 addl_i 這個指令的 Pattern，其中： insn[31:26] 為 010000。 insn[11:5] 為 0000000。 參考了 Part 1. Examples 定義的 @opi Format。 由於 Pattern 的所有 bits 都必須明確的被定義，因此 @opi 必須包含其餘 insn[25:12] 及 insn[4:0] 的格式定義，否則 Decodetree 便會報錯。 最後 addl_i 的 decoder 還會呼叫 trans_addl_i() 這個 translator function。 搭配之前介紹的 Fields、Argument Sets 及 Formats，讓我們再看幾個完整的例子應該會更清楚 Decodetree 是怎產生一個指令的 decoder 的。 首先是 RISC-V 的 lui 及 auipc 指令： 123456789101112131415161718# Fields:%rd 7:5# immediates:%imm_u 12:s20 !function=ex_shift_12# Argument sets:&amp;u imm rd# Formats:@u .................... ..... ....... &amp;u imm=%imm_u %rd# Patternslui .................... ..... 0110111 @uauipc .................... ..... 0010111 @u 會產生以下 lui 及 auipc 的 decoder： 123456789101112131415161718192021222324252627282930313233typedef struct { int imm; int rd;} arg_u;static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn){ a-&gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-&gt;rd = extract32(insn, 7, 5);}static bool decode_insn32(DisasContext *ctx, uint32_t insn){ union { arg_u f_u; } u; decode_insn32_extract_u(ctx, &amp;u.f_u, insn); switch (insn &amp; 0x0000007f) { case 0x00000017: /* ........ ........ ........ .0010111 */ /* ./insn32.decode:18 */ if (trans_auipc(ctx, &amp;u.f_u)) return true; return false; case 0x00000037: /* ........ ........ ........ .0110111 */ /* ./insn32.decode:17 */ if (trans_lui(ctx, &amp;u.f_u)) return true; return false; } return false;} 回顧到目前為止所介紹的： Argument Sets：&amp;u 這個 argument set 包含了 imm 及 rd 這兩個 arguments。 1234typedef struct { int imm; int rd;} arg_u; Fields： imm 及 rd 分別位在 insn[31:12] 及 insn[11:7]，且 imm 為 sign-extended。最後在擷取出 imm 的值後，還會呼叫 ex_shift_12()。 12a-&gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20));a-&gt;rd = extract32(insn, 7, 5); Formats：@u 定義了 RISC-V U-type 指令的格式 參考了 &amp;u 這個 Argument Set，因此 decode function 會傳入 arg_u 作為參數。 insn[31:12] 參考了 imm_u 這個 Field (並重新命名為 imm) insn[11:7] 參考了 rd 這個 Field。 12345static void decode_insn32_extract_u(DisasContext *ctx, arg_u *a, uint32_t insn){ a-&gt;imm = ex_shift_12(ctx, sextract32(insn, 12, 20)); a-&gt;rd = extract32(insn, 7, 5);} Patterns： lui 的 opcode (insn[6:0]) 為 0010111，也就是 0x17，在產生出來的 switch-case 中可以看到其對應的 case。 lui 的 decoder 最後呼叫了 trans_lui()，並傳入 DisasContext 及經由 decode_insn32_extract_u() 所解析出來的 arg_u。 auipc 的 opcode (insn[6:0]) 為 0110111，也就是 0x37，在產生出來的 switch-case 中可以看到其對應的 case。 auipc 的 decoder 最後呼叫了 trans_auipc()，並傳入 DisasContext 及經由 decode_insn32_extract_u() 所解析出來的 arg_u。 P.S. 這邊由於 Decodetree 發現 lui 及 auipc 可以共用 decode_insn32_extract_u()，因此將其提到了 switch-case 之外。 123456789101112131415161718192021static bool decode_insn32(DisasContext *ctx, uint32_t insn){ union { arg_u f_u; } u; decode_insn32_extract_u(ctx, &amp;u.f_u, insn); switch (insn &amp; 0x0000007f) { case 0x00000017: /* ........ ........ ........ .0010111 */ /* ./insn32.decode:18 */ if (trans_auipc(ctx, &amp;u.f_u)) return true; return false; case 0x00000037: /* ........ ........ ........ .0110111 */ /* ./insn32.decode:17 */ if (trans_lui(ctx, &amp;u.f_u)) return true; return false; } return false;} 我們另外可以發現，Pattern + Format 把所有的 32-bits 都給了明確的定義： Pattern 定義了 opcode (insn[6:0])。 Format 參考了 imm (insn[31:12]) 及 rd (insn[11:7])。 如果有任何未明確定義的 bits 的話，Decodetree 便會報錯，例如如果我們將 lui 的 opcode 最高 2 個 bits (insn[6:5]) 由 01 改成 ..： 1lui .................... ..... ..10111 @u Decodetree 在解析時，便會報錯： ./insn32.decode:17: error: (‘bits left unspecified (0x00000060)’,) Decodetree 提醒我們，insn[6:5] (0x00000060) 尚未給出明確定義，並會顯示出其錯誤的行數。 trans_lui() 和 trans_auipc() 被定義在 target/riscv/insn_trans/trans_rvi.inc.c： 123456789101112131415static bool trans_lui(DisasContext *ctx, arg_lui *a){ if (a-&gt;rd != 0) { tcg_gen_movi_tl(cpu_gpr[a-&gt;rd], a-&gt;imm); } return true;}static bool trans_auipc(DisasContext *ctx, arg_auipc *a){ if (a-&gt;rd != 0) { tcg_gen_movi_tl(cpu_gpr[a-&gt;rd], a-&gt;imm + ctx-&gt;base.pc_next); } return true;} 可以看到 trans_*() 負責實際指令的 business logics 及產生對應的 TCG codes。 如同先前所介紹，Patterns 的 pat_elt 也可以採用 field_elt 語法，如 RISC-V 的 fence 指令： 1fence ---- pred:4 succ:4 ----- 000 ----- 0001111 insn[27:24] 為 pred。 insn[23:20] 為 succ。 insn[14:12] 固定為 000。 insn[6:0] 為 opcode (0001111)。 沒有參考任何的 Format。 剩下的 insn[31:28]、insn[19:15]、insn[11:7] 被宣告為 -，因此就算沒有被明確定義也沒有關係。 所生成 fence 的 decoder 如下： 12345678910111213141516171819202122232425262728typedef struct { int pred; int succ;} arg_decode_insn320;static void decode_insn32_extract_decode_insn32_Fmt_0(DisasContext *ctx, arg_decode_insn320 *a, uint32_t insn){ a-&gt;pred = extract32(insn, 24, 4); a-&gt;succ = extract32(insn, 20, 4);}static bool decode_insn32(DisasContext *ctx, uint32_t insn){ union { arg_decode_insn320 f_decode_insn320; } u; decode_insn32_extract_decode_insn32_Fmt_0(ctx, &amp;u.f_decode_insn320, insn); switch (insn &amp; 0x0000707f) { case 0x0000000f: /* ........ ........ .000.... .0001111 */ /* ./insn32.decode:2 */ if (trans_fence(ctx, &amp;u.f_decode_insn320)) return true; return false; } return false;} 值得注意的是，雖然這次我們沒有參考任何的 Argument Set，但 Decodetree 還是替我們生成了一個包含 pred 和 succ 的 arg_decode_insn320 。 trans_fence() 同樣是被定義在 ./target/riscv/insn_trans/trans_rvi.inc.c： 123456static bool trans_fence(DisasContext *ctx, arg_fence *a){ /* FENCE is a full memory barrier. */ tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC); return true;} Pattern Groups Pattern Groups 由一個以上的 Patterns 所組成，其主要差別是不同 Patterns 之間的 bits 可以 overlap。當同組中有多個 Patterns 時，會依據該組中各 Pattern 的宣告順序依序判斷目前的指令是否符合其定義。除此之外，當符合的 Pattern 其 trans_*() 回傳值為 false 時，也會被視為不相符，而繼續判斷該組中的下一個 Pattern。因此 Pattern Groups 非常適合將多個相似格式的指令給組成同一個 Pattern Group。 原文說明如下： Unlike ungrouped patterns, grouped patterns are allowed to overlap. Conflicts are resolved by selecting the patterns in order. If all of the fixedbits for a pattern match, its translate function will be called. If the translate function returns false, then subsequent patterns within the group will be matched. 1group := &apos;{&apos; ( pat_def | group )+ &apos;}&apos; 各 Pattern Group 以 { 開頭，並以 } 結尾，且允許 nested pattern groups 的存在，其他語法皆與 Pattern 相同。 Examples 1234567{ { nop 000010 ----- ----- 0000 001001 0 00000 copy 000010 00000 r1:5 0000 001001 0 rt:5 } or 000010 rt2:5 r1:5 cf:4 001001 0 rt:5} 會產生以下的 decoder： 12345678910111213141516171819202122switch (insn &amp; 0xfc000fe0) {case 0x08000240: /* 000010.. ........ ....0010 010..... */ if ((insn &amp; 0x0000f000) == 0x00000000) { /* 000010.. ........ 00000010 010..... */ if ((insn &amp; 0x0000001f) == 0x00000000) { /* 000010.. ........ 00000010 01000000 */ extract_decode_Fmt_0(&amp;u.f_decode0, insn); if (trans_nop(ctx, &amp;u.f_decode0)) return true; // 這邊沒有直接回傳 false，讓 switch-case 繼續往下執行 } if ((insn &amp; 0x03e00000) == 0x00000000) { /* 00001000 000..... 00000010 010..... */ extract_decode_Fmt_1(&amp;u.f_decode1, insn); if (trans_copy(ctx, &amp;u.f_decode1)) return true; 　// 這邊沒有直接回傳 false，讓 switch-case 繼續往下執行 } } extract_decode_Fmt_2(&amp;u.f_decode2, insn); if (trans_or(ctx, &amp;u.f_decode2)) return true; return false;} 當指令的值符合 nop 及 copy 這個內層 Pattern Group 時，會先判斷該指令是否符合 nop 指令的定義，且 trans_nop() 的回傳值為 true。否則的話，就會繼續判斷是否符合同組中的 copy 指令。若都不符，就會再判斷是否符合外層 Pattern Group 的 or 指令。若仍不符，才會回傳 false 表示 decode 失敗。 與單純使用 Pattern 最大不同的是，當一 Pattern 的 trans_*() 回傳值為 false 時，不會直接回傳 false (代表 decode 失敗)，而是會接續著判斷後續的 Patterns 是否相符。 RISC-V Compressed-Extension 中的 c.ebreak、c.jalr、及 c.add 指令，由於這三個指令的格式非常相似，因此非常適合使用 Pattern Group 來定義： RISC-V spec. 中定義： C.EBREAK shares the opcode with the C.ADD instruction, but with rd and rs2 both zero, thus can also use the CR format. C.JALR is only valid when rs1≠x0; the code point with rs1=x0 corresponds to the C.EBREAK instruction. C.ADD is only valid when rs2≠x0; the code points with rs2=x0 correspond to the C.JALR and C.EBREAK instructions. The code points with rs2̸=x0 and rd=x0 are HINTs. c.ebreak、c.jalr、c.add 三個指令： insn[15:13]、insn[12]、insn[1:0] 的值皆相同。 當 insn[11:7] 且 insn[6:2] 的值皆為 0 (rs1=0 且 rs2=0) 時為 c.ebreak 指令。 當只有 insn[11:7] 的值為 0 (rs1=0 且 rs2≠0) 時為 c.jalr 指令。 否則為 c.add 指令 (rs1≠x0 且 rs2≠0)。 123456789101112131415161718192021# Fields%rd 7:5%rs2_5 2:5# Argument Sets&amp;r rd rs1 rs2 !extern&amp;i imm rs1 rd !extern# Formats@cr .... ..... ..... .. &amp;r rs2=%rs2_5 rs1=%rd %rd@c_jalr ... . ..... ..... .. &amp;i imm=0 rs1=%rd# Pattern Groups{ ebreak 100 1 00000 00000 10 jalr 100 1 ..... 00000 10 @c_jalr rd=1 # C.JALR add 100 1 ..... ..... 10 @cr} 所生成的 decoder 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static void decode_insn16_extract_c_jalr(DisasContext *ctx, arg_i *a, uint16_t insn){ a-&gt;imm = 0; // 在 c_jalr 的 Format 中指定 imm 的值為 0 a-&gt;rs1 = extract32(insn, 7, 5);}static void decode_insn16_extract_cr(DisasContext *ctx, arg_r *a, uint16_t insn){ a-&gt;rs2 = extract32(insn, 2, 5); a-&gt;rs1 = extract32(insn, 7, 5); a-&gt;rd = extract32(insn, 7, 5);}static void decode_insn16_extract_decode_insn16_Fmt_2(DisasContext *ctx, arg_decode_insn162 *a, uint16_t insn){static bool decode_insn16(DisasContext *ctx, uint16_t insn){ union { arg_decode_insn162 f_decode_insn162; arg_i f_i; arg_r f_r; } u; switch (insn &amp; 0x0000f003) { case 0x00009002: /* 1001.... ......10 */ if ((insn &amp; 0x00000ffc) == 0x00000000) { /* 10010000 00000010 */ /* ./insn16.decode:20 */ decode_insn16_extract_decode_insn16_Fmt_2(ctx, &amp;u.f_decode_insn162, insn); if (trans_ebreak(ctx, &amp;u.f_decode_insn162)) return true; // 這邊沒有直接回傳 false，讓 switch-case 繼續往下執行 } if ((insn &amp; 0x0000007c) == 0x00000000) { /* 1001.... .0000010 */ /* ./insn16.decode:21 */ decode_insn16_extract_c_jalr(ctx, &amp;u.f_i, insn); u.f_i.rd = 1; // 在 jalr 的 Pattern 中指定 rd 的值為 0。 if (trans_jalr(ctx, &amp;u.f_i)) return true; // 這邊沒有直接回傳 false，讓 switch-case 繼續往下執行 } /* ./insn16.decode:22 */ decode_insn16_extract_cr(ctx, &amp;u.f_r, insn); if (trans_add(ctx, &amp;u.f_r)) return true; return false; } return false;} 當指令格式符合 c.ebreak、c.jalr、c.add 的 Pattern Group 時，會依序判斷該指令是否符合 c.ebreak、c.jalr、c.add 的定義以及其對應的 trans_*()。 另外值得一提的是，在 c_jalr Format 和 jalr Pattern 中有分別指定其 imm 及 rd 的值為 0，所生成的 codes 也會分別在對應的地方將該值設為 0 (見 codes 註解說明)。 以上就是 Decodetree 的語法說明。透過 Decodetree，我們不用再像以前以樣寫一大包的 switch-case 來 decode 指令。將不同類型的指令寫至不同的 decode 檔，不僅方便維護，閱讀起來也更為容易。","link":"/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/"},{"title":"QEMU: 使用 Decodetree 新增 RISC-V 指令","text":"⚠️ 本文所使用的 QEMU 版本為：v4.2.0 在之前的文章中 (Part 1., Part 2.) 我們提到了如何使用 Decodetree 來定義指令的 decoder。本篇文章就實際使用 Decodetree 來定義一個 QEMU RISC-V 目前尚未支援的指令 - B(itmanip) Extension 中的 pcnt 指令，並實做其行為。 pcnt 指令 pcnt 指令的定義如下： This instruction counts the number of 1 bits in a register. This operations is known as population count, popcount, sideways sum, bit summation, or Hamming weight. 其指令格式為： | 1 0 9 8 7 6 5 | 4 3 2 1 0 | 9 8 7 6 5 | 4 3 2 | 1 0 9 8 7 | 6 5 4 3 2 1 0 | |===========================================================================| | 0110000 | 00010 | rs1 | 001 | rd | 0010011 | PCNT 安裝 toolchain 由於 B Extension 尚未正式定稿 (Draft)，因此必須至 riscv-bitmanip repo 下載 toolchain，並依照該 repo 的指示安裝： sudo mkdir /opt/riscv64b sudo chown $USER: /opt/riscv64b bash build-all.sh 此安裝除了 toolchain 外，還會安裝支援 B Extension 的 Spike (riscv-isa-sim) 及 riscv-pk (P.S. 目前的 script 是寫死安裝路徑為：/opt/riscv64b)。 範例程式 在安裝好後，我們可以寫一個範例程式，並搭配 Spike 來做測試： pcnt_example.c12345678910111213141516171819202122#include &amp;lt;stdio.h&amp;gt;int count_set_bits(int num){ int count; __asm__(&quot;pcnt %0, %1\\n&quot; : &quot;=r&quot;(count) : &quot;r&quot;(num) :); return count;}int main(void){ int num = 187; int result = count_set_bits(num); printf(&quot;num = %d\\n&quot;, num); printf(&quot;# of set bits = %d\\n&quot;, result); return 0;} 此範例程式做的事情很簡單，透過 inline assembly：pcnt 指令，將 int num = 187 的 1 bits 個數給計算出來。 透過剛剛的 toolchain 編譯此程式： /opt/riscv64b/bin/riscv64-unknown-elf-gcc -Wall -march=rv64gb -Os -o pcnt_example pcnt_example.c -march=rv64gb：指定 target ISA 為 RISC-V 64-bit + g (IMAFD base) + b (B Extension)。 透過 objdump 觀看其反組譯碼： /opt/riscv64b/bin/riscv64-unknown-elf-objdump -S pcnt_example &gt; pcnt_example.s pcnt_example.s123456789101112131415161718192021222324pcnt_example: file format elf64-littleriscvDisassembly of section .text:00000000000100b0 &lt; main &gt;: 100b0: 00017537 lui a0,0x17 100b4: ff010113 addi sp,sp,-16 100b8: 0bb00593 li a1,187 100bc: 8b850513 addi a0,a0,-1864 # 168b8 &lt;__trunctfdf2+0x2ce&gt; 100c0: 00113423 sd ra,8(sp) 100c4: 00813023 sd s0,0(sp) 100c8: 2ac000ef jal ra,10374 &lt;printf&gt; 100cc: 0bb00413 li s0,187 100d0: 00017537 lui a0,0x17 100d4: 60241413 pcnt s0,s0 100d8: 0004041b sext.w s0,s0 100dc: 00040593 mv a1,s0 100e0: 8c850513 addi a0,a0,-1848 # 168c8 &lt;__trunctfdf2+0x2de&gt; 100e4: 290000ef jal ra,10374 &lt;printf&gt; 100e8: 00813083 ld ra,8(sp) 100ec: 00013403 ld s0,0(sp) 100f0: 00000513 li a0,0 100f4: 01010113 addi sp,sp,16 100f8: 00008067 ret 可以看到 Line:15 呼叫了 pcnt 指令：pcnt s0, s0。 透過 Spike 執行程式： /opt/riscv64b/bin/spike --isa=RV64GCB pk pcnt_example bbl loader num = 187 # of set bits = 6 187 的二進位為 10111011，1 bits 個數為 6，與程式輸出的結果一致。 同樣的程式，我們使用 QEMU 來執行： ./qemu/riscv64-linux-user/qemu-riscv64 pcnt_example num = 187 Illegal instruction 可以看到，目前 QEMU 尚未支援 pcnt 指令，因此當執行到 pcnt 指令時，便會噴 Illegal instruction 的錯誤訊息。 在 QEMU 中新增 pcnt 指令 根據前述 B Extension spec. 所列的 pcnt 指令格式，參考目前 QEMU RISC-V 現有的 Decodetree：target/riscv/insn32.decode，pcnt 的 Pattern 可以搭配 @r2 的 Format (只有 rs1 及 rd 這兩個 Fields)，其完整定義如下： Field ./target/riscv/insn32.decode2223%rs1 15:5%rd 7:5 Format ./target/riscv/insn32.decode64@r2 ....... ..... ..... ... ..... ....... %rs1 %rd Pattern 我們可以定義 pcnt 的 Pattern 如下： ./target/riscv/insn32.decode207208# *** RV32B Standard Extension ***pcnt 0110000 00010 ..... 001 ..... 0010011 @r2 所會產生的 decoder 如下： ./riscv64-linux-user/target/riscv/decode_insn32.inc.c38394041typedef struct { int rd; int rs1;} arg_decode_insn3213; ./riscv64-linux-user/target/riscv/decode_insn32.inc.c491492493494495static void decode_insn32_extract_r2(DisasContext *ctx, arg_decode_insn3213 *a, uint32_t insn){ a-&gt;rs1 = extract32(insn, 15, 5); a-&gt;rd = extract32(insn, 7, 5);} ./riscv64-linux-user/target/riscv/decode_insn32.inc.c673674675676677678679680681682683684685686&lt;pre&gt; case 0x1: /* 01...... ........ .001.... .0010011 */ decode_insn32_extract_r2(ctx, &amp;u.f_decode_insn3213, insn); switch ((insn &gt;&gt; 20) &amp; 0x3ff) { case 0x202: /* 01100000 0010.... .001.... .0010011 */ /* /home/frankchang/qemu/target/riscv/insn32.decode:208 */ if (trans_pcnt(ctx, &amp;u.f_decode_insn3213)) return true; return false; } return false; }&lt;/pre&gt; 由於 @r2 Format 並沒有參考任何的 Argument Set，因此 Decodetree 會自動根據 Format 所參考到的 Fields (rs1、rd) 動態產生 argument set struct: arg_decode_insn3213。 此外，由 pcnt Pattern 所產生的 decode function 會呼叫 decode_insn32_extract_r2() 這個 extract function 來解析指令中 rs2 及 rd 欄位的值，並更新所傳入 arg_decode_insn3213 對應的欄位，而後再呼叫 trans_pcnt() 來執行 pcnt 指令 (產生對應的 TCG ops)。因此，我們還必須定義 trans_pcnt() 來實作 pcnt 的指令行為。 參考 B Extension spec. 中，pcnt 指令的實作： 1234567uint_xlen_t pcnt(uint_xlen_t rs1){ int count = 0; for (int index = 0; index &lt; XLEN; index++) count += (rs1 &gt;&gt; index) &amp; 1; return count;} 及 Spike 中，pcnt 指令的實作： riscv-isa-sim/riscv/insns/pcnt.h 12345require_extension(&apos;B&apos;);reg_t x = 0;for (int i = 0; i &lt; xlen; i++) if (1 &amp; (RS1 &gt;&gt; i)) x++;WRITE_RD(sext_xlen(x)); 實作很簡單，每次迴圈 right shift rs1 i 個 bits 並與 1 做 AND，若為 true 就將 count 加 1，最後回傳的 count 就是 1 bits 個數。 trans_pcnt() 實作了 pcnt 指令對應的 TCG ops。QEMU 在執行時，會將 target instructions (e.g. RISC-V instructions) 轉譯成 TCG ops，而 TCG ops 則會再轉譯為 host instructions (e.g. x86 instruction)。 QEMU dynamic instructions translation+---------------------+ +---------+ +-------------------+| Target Instructions | ---&gt; | TCG ops | ---&gt; | Host instructions |+---------------------+ +---------+ +-------------------+ (e.g. RISC-V) (e.g. x86) 關於 TCG 的說明，可以參考 QEMU 的 documentations：Translator Internals、TCG README。 新增一檔案：./target/riscv/insn_trans/trans_rvb.inc.c 來定義 B Extension 指令的實作 (當然，目前只有 pcnt 指令)： ./target/riscv/insn_trans/trans_rvb.inc.c12345678910111213/* * RISC-V translation routines for the RVB Standard Extension. */static bool trans_pcnt(DisasContext *ctx, arg_pcnt *a) { if (a-&gt;rd != 0) { TCGv t0 = tcg_temp_new(); gen_get_gpr(t0, a-&gt;rs1); gen_helper_pcnt(cpu_gpr[a-&gt;rd], t0); tcg_temp_free(t0); } return true;} 由於對 x0 (zero register) 的寫入都會被忽略，因此首先判斷 rd 是否為 0，若為 0 則不做任何的事情。 再來宣告一 TCG variable：t0，並透過 gen_get_gpr() 將 rs1 暫存器的值 (如 pcnt_example 中 pcnt s0, s0 指令，rs1 即為 s0，也就是 x8)，載入到 t0。 這邊還呼叫了我們所定義幫我們處理 pcnt 計算 1 bits 個數的 pcnt helper function：gen_helper_pcnt()。該 helper function 會在計算完後，將最後的結果存至 rd (i.e. cpu_gpr[a-&gt;rd]) 暫存器中。 最後別忘了要釋放之前所宣告的 TCG variable：t0。 P.S. 其實這邊可以更簡單的直接將 cpu_gpr[a-&gt;rs1] 傳入，省略 TCG variable：t0 的宣告： ./target/riscv/insn_trans/trans_rvb.inc.c12345678910/* * RISC-V translation routines for the RVB Standard Extension. */static bool trans_pcnt(DisasContext *ctx, arg_pcnt *a) { if (a-&gt;rd != 0) { gen_helper_pcnt(cpu_gpr[a-&gt;rd], cpu_gpr[a-&gt;rs1]); } return true;} pcnt 的 helper function 定義如下： ./target/riscv/helper.h12/* Bitmanip Extension */DEF_HELPER_1(pcnt, tl, tl) ./target/riscv/bitmanip_helper.c12345678910111213141516/* * RISC-V Bitmanip Extension Helpers for QEMU. */#include &quot;qemu/osdep.h&quot;#include &quot;cpu.h&quot;#include &quot;exec/exec-all.h&quot;#include &quot;exec/helper-proto.h&quot;target_ulong HELPER(pcnt)(target_ulong rs1){ target_ulong count = 0; for (int i = 0; i &lt; TARGET_LONG_BITS; i++) { count += (rs1 &gt;&gt; i) &amp; 1;; } return count;} 基本上就是實作先前在 B Extension spec. 及 Spike 中所看到的 1 bits 個數計算方式。由於 pcnt helper function 只需接收 rs1 暫存器的值，並回傳最後 1 bits 個數的結果，因此，我們定義 pcnt 的 helper function 為接收一 target_ulong 型態的 rs1 並回傳 target_ulong 型態的 1 bits 個數結果。 最後別忘了將我們新增的 bitmanip_helper.o 加入 compile objects 列表： ./target/riscv/Makefile.objs1obj-y += translate.o op_helper.o cpu_helper.o cpu.o csr.o fpu_helper.o bitmanip_helper.o gdbstub.o 重新編譯 QEMU，再次執行 pcnt_example： ./qemu/riscv64-linux-user/qemu-riscv64 pcnt_example num = 187 # of set bits = 6 這次 QEMU 就可以正確的 decode 並執行 pcnt 指令了。 在 QEMU 中新增指令的流程大致就如同本文所介紹，不過由於 pcnt 指令只是單純的 bit operation 指令，沒有像 csr 相關指令會涉及 CPURISCVState 的更新，以及像 jal 指令會涉及 DisasContext 的判斷，因此實作起來相對簡單。若欲讓 QEMU 支援不論是 B Extension 或是 V Extension 的其他指令，就是得好好 K spec. 並一個一個新增了。 另外最近剛好 C-Sky Microsystems 的 LIU Zhiwei &amp;lt;zhiwei_liu@c-sky.com&amp;gt; 在實作 V Extension 的 configure instructions：vsetvl 及 vsetvli，比起本文所介紹之 B Extension 的 pcnt 指令要來得複雜得多，patches 仍在被 reviewed 中，也可以做為參考。 本文所對 QEMU 做的修正，可以參考此 commit。","link":"/QEMU-%E4%BD%BF%E7%94%A8-Decodetree-%E6%96%B0%E5%A2%9E-RISC-V-%E6%8C%87%E4%BB%A4/"}],"tags":[{"name":"C","slug":"C","link":"/tags/C/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Linux Kernel","slug":"Linux-Kernel","link":"/tags/Linux-Kernel/"},{"name":"QEMU","slug":"QEMU","link":"/tags/QEMU/"},{"name":"RISC-V","slug":"RISC-V","link":"/tags/RISC-V/"}],"categories":[{"name":"Linux Kernel","slug":"Linux-Kernel","link":"/categories/Linux-Kernel/"},{"name":"QEMU","slug":"QEMU","link":"/categories/QEMU/"},{"name":"Tricks","slug":"Linux-Kernel/Tricks","link":"/categories/Linux-Kernel/Tricks/"},{"name":"RISC-V","slug":"QEMU/RISC-V","link":"/categories/QEMU/RISC-V/"}]}