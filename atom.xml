<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xc0de</title>
  
  <subtitle>Blog by Frank Chang</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0xc0de.tw/"/>
  <updated>2020-04-28T14:23:10.336Z</updated>
  <id>https://0xc0de.tw/</id>
  
  <author>
    <name>Frank Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QEMU: 使用 Decodetree 新增 RISC-V 指令</title>
    <link href="https://0xc0de.tw/QEMU-%E4%BD%BF%E7%94%A8-Decodetree-%E6%96%B0%E5%A2%9E-RISC-V-%E6%8C%87%E4%BB%A4/"/>
    <id>https://0xc0de.tw/QEMU-%E4%BD%BF%E7%94%A8-Decodetree-%E6%96%B0%E5%A2%9E-RISC-V-%E6%8C%87%E4%BB%A4/</id>
    <published>2020-02-16T09:30:00.000Z</published>
    <updated>2020-04-28T14:23:10.336Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⚠️ 本文所使用的 QEMU 版本為：<code>v4.2.0</code></p></blockquote><p>在之前的文章中 (<a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1">Part 1.</a>, <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2">Part 2.</a>) 我們提到了如何使用 <code>Decodetree</code> 來定義指令的 decoder。本篇文章就實際使用 <code>Decodetree</code> 來定義一個 QEMU RISC-V 目前尚未支援的指令 - <code>B(itmanip) Extension</code> 中的 <code>pcnt</code> 指令，並實做其行為。</p><a id="more"></a><hr><h1 id="pcnt-指令"><a class="header-anchor" href="#pcnt-指令"></a>pcnt 指令</h1><p><code>pcnt</code> 指令的定義如下：</p><blockquote><p>This instruction counts the number of 1 bits in a register. This operations is known as population<br>count, popcount, sideways sum, bit summation, or Hamming weight.</p></blockquote><p>其指令格式為：</p><pre><code>| 1 0 9 8 7 6 5 | 4 3 2 1 0 | 9 8 7 6 5 | 4 3 2 | 1 0 9 8 7 | 6 5 4 3 2 1 0 ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||    0110000    |   00010   |    rs1    |  001  |     rd    |    0010011    | PCNT</code></pre><hr><h1 id="安裝-toolchain"><a class="header-anchor" href="#安裝-toolchain"></a>安裝 toolchain</h1><p>由於 <code>B Extension</code> 尚未正式定稿 (Draft)，因此必須至 <a href="https://github.com/riscv/riscv-bitmanip/tree/master/tools" target="_blank" rel="noopener">riscv-bitmanip repo</a> 下載 toolchain，並依照該 repo 的指示安裝：</p><pre><code>sudo mkdir &#x2F;opt&#x2F;riscv64bsudo chown $USER: &#x2F;opt&#x2F;riscv64bbash build-all.sh</code></pre><p>此安裝除了 toolchain 外，還會安裝支援 <code>B Extension</code> 的 <code>Spike (riscv-isa-sim)</code> 及 <code>riscv-pk</code> (P.S. 目前的 script 是寫死安裝路徑為：<code>/opt/riscv64b</code>)。</p><hr><h1 id="範例程式"><a class="header-anchor" href="#範例程式"></a>範例程式</h1><p>在安裝好後，我們可以寫一個範例程式，並搭配 Spike 來做測試：</p><figure class="highlight c"><figcaption><span>pcnt_example.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_set_bits</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    __asm__(<span class="string">"pcnt %0, %1\n"</span></span><br><span class="line">            : <span class="string">"=r"</span>(count)</span><br><span class="line">            : <span class="string">"r"</span>(num)</span><br><span class="line">            :);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">187</span>;</span><br><span class="line">    <span class="keyword">int</span> result = count_set_bits(num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num = %d\n"</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"# of set bits = %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此範例程式做的事情很簡單，透過 inline assembly：<code>pcnt</code> 指令，將 <code>int num = 187</code> 的 <code>1 bits</code> 個數給計算出來。</p><p>透過剛剛的 toolchain 編譯此程式：</p><pre><code>&#x2F;opt&#x2F;riscv64b&#x2F;bin&#x2F;riscv64-unknown-elf-gcc -Wall -march&#x3D;rv64gb -Os -o pcnt_example pcnt_example.c</code></pre><ul><li>-march=rv64gb：指定 target ISA 為 <code>RISC-V 64-bit</code> + <code>g (IMAFD base)</code> + <code>b (B Extension)</code>。</li></ul><p>透過 objdump 觀看其反組譯碼：</p><pre><code>&#x2F;opt&#x2F;riscv64b&#x2F;bin&#x2F;riscv64-unknown-elf-objdump -S pcnt_example &gt; pcnt_example.s</code></pre><figure class="highlight plain"><figcaption><span>pcnt_example.s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pcnt_example:     file format elf64-littleriscv</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000000100b0 &lt; main &gt;:</span><br><span class="line">   100b0:       00017537                lui     a0,0x17</span><br><span class="line">   100b4:       ff010113                addi    sp,sp,-16</span><br><span class="line">   100b8:       0bb00593                li      a1,187</span><br><span class="line">   100bc:       8b850513                addi    a0,a0,-1864 # 168b8 &lt;__trunctfdf2+0x2ce&gt;</span><br><span class="line">   100c0:       00113423                sd      ra,8(sp)</span><br><span class="line">   100c4:       00813023                sd      s0,0(sp)</span><br><span class="line">   100c8:       2ac000ef                jal     ra,10374 &lt;printf&gt;</span><br><span class="line">   100cc:       0bb00413                li      s0,187</span><br><span class="line">   100d0:       00017537                lui     a0,0x17</span><br><span class="line">   100d4:       60241413                pcnt    s0,s0</span><br><span class="line">   100d8:       0004041b                sext.w  s0,s0</span><br><span class="line">   100dc:       00040593                mv      a1,s0</span><br><span class="line">   100e0:       8c850513                addi    a0,a0,-1848 # 168c8 &lt;__trunctfdf2+0x2de&gt;</span><br><span class="line">   100e4:       290000ef                jal     ra,10374 &lt;printf&gt;</span><br><span class="line">   100e8:       00813083                ld      ra,8(sp)</span><br><span class="line">   100ec:       00013403                ld      s0,0(sp)</span><br><span class="line">   100f0:       00000513                li      a0,0</span><br><span class="line">   100f4:       01010113                addi    sp,sp,16</span><br><span class="line">   100f8:       00008067                ret</span><br></pre></td></tr></table></figure><p>可以看到 <code>Line:15</code> 呼叫了 <code>pcnt</code> 指令：<code>pcnt s0, s0</code>。</p><p>透過 Spike 執行程式：</p><pre><code>&#x2F;opt&#x2F;riscv64b&#x2F;bin&#x2F;spike --isa&#x3D;RV64GCB pk pcnt_example</code></pre><pre><code>bbl loadernum &#x3D; 187# of set bits &#x3D; 6</code></pre><p><code>187</code> 的二進位為 <code>10111011</code>，<code>1 bits</code> 個數為 <code>6</code>，與程式輸出的結果一致。</p><p>同樣的程式，我們使用 QEMU 來執行：</p><pre><code>.&#x2F;qemu&#x2F;riscv64-linux-user&#x2F;qemu-riscv64 pcnt_example</code></pre><pre><code>num &#x3D; 187Illegal instruction</code></pre><p>可以看到，目前 QEMU 尚未支援 <code>pcnt</code> 指令，因此當執行到 <code>pcnt</code> 指令時，便會噴 <code>Illegal instruction</code> 的錯誤訊息。</p><hr><h1 id="在-QEMU-中新增-pcnt-指令"><a class="header-anchor" href="#在-QEMU-中新增-pcnt-指令"></a>在 QEMU 中新增 pcnt 指令</h1><p>根據前述 <code>B Extension</code> spec. 所列的 <code>pcnt</code> 指令格式，參考目前 QEMU RISC-V 現有的 <code>Decodetree</code>：<code>target/riscv/insn32.decode</code>，<code>pcnt</code> 的 <code>Pattern</code> 可以搭配 <code>@r2</code> 的 <code>Format</code> (只有 <code>rs1</code> 及 <code>rd</code> 這兩個 <code>Fields</code>)，其完整定義如下：</p><h3 id="Field"><a class="header-anchor" href="#Field"></a>Field</h3><figure class="highlight plain"><figcaption><span>./target/riscv/insn32.decode</span></figcaption><table><tr><td class="gutter"><pre><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%rs1       15:5</span><br><span class="line">%rd        7:5</span><br></pre></td></tr></table></figure><h3 id="Format"><a class="header-anchor" href="#Format"></a>Format</h3><figure class="highlight plain"><figcaption><span>./target/riscv/insn32.decode</span></figcaption><table><tr><td class="gutter"><pre><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@r2      .......   ..... ..... ... ..... ....... %rs1 %rd</span><br></pre></td></tr></table></figure><h3 id="Pattern"><a class="header-anchor" href="#Pattern"></a>Pattern</h3><p>我們可以定義 <code>pcnt</code> 的 <code>Pattern</code> 如下：</p><figure class="highlight plain"><figcaption><span>./target/riscv/insn32.decode</span></figcaption><table><tr><td class="gutter"><pre><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"># *** RV32B Standard Extension ***</span><br><span class="line">pcnt       0110000  00010 ..... 001 ..... 0010011 @r2</span><br></pre></td></tr></table></figure><p>所會產生的 decoder 如下：</p><figure class="highlight c"><figcaption><span>./riscv64-linux-user/target/riscv/decode_insn32.inc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> rd;</span><br><span class="line">    <span class="keyword">int</span> rs1;</span><br><span class="line">&#125; arg_decode_insn3213;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>./riscv64-linux-user/target/riscv/decode_insn32.inc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32_extract_r2</span><span class="params">(DisasContext *ctx, arg_decode_insn3213 *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;rs1 = extract32(insn, <span class="number">15</span>, <span class="number">5</span>);</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><figcaption><span>./riscv64-linux-user/target/riscv/decode_insn32.inc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x1</span>:</span><br><span class="line">                <span class="comment">/* 01...... ........ .001.... .0010011 */</span></span><br><span class="line">                decode_insn32_extract_r2(ctx, &amp;u.f_decode_insn3213, insn);</span><br><span class="line">                <span class="keyword">switch</span> ((insn &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0x3ff</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x202</span>:</span><br><span class="line">                    <span class="comment">/* 01100000 0010.... .001.... .0010011 */</span></span><br><span class="line">                    <span class="comment">/* /home/frankchang/qemu/target/riscv/insn32.decode:208 */</span></span><br><span class="line">                    <span class="keyword">if</span> (trans_pcnt(ctx, &amp;u.f_decode_insn3213)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>由於 <code>@r2 Format</code> 並沒有參考任何的 <code>Argument Set</code>，因此 <code>Decodetree</code> 會自動根據 <code>Format</code> 所參考到的 <code>Fields</code> (<code>rs1</code>、<code>rd</code>) 動態產生 <code>argument set struct</code>: <code>arg_decode_insn3213</code>。</p><p>此外，由 <code>pcnt Pattern</code> 所產生的 decode function 會呼叫 <code>decode_insn32_extract_r2()</code> 這個 extract function 來解析指令中 <code>rs2</code> 及 <code>rd</code> 欄位的值，並更新所傳入 <code>arg_decode_insn3213</code> 對應的欄位，而後再呼叫 <code>trans_pcnt()</code> 來執行 <code>pcnt</code> 指令 (產生對應的 <code>TCG ops</code>)。因此，我們還必須定義 <code>trans_pcnt()</code> 來實作 <code>pcnt</code> 的指令行為。</p><hr><p>參考 <code>B Extension</code> spec. 中，<code>pcnt</code> 指令的實作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint_xlen_t</span> <span class="title">pcnt</span><span class="params">(<span class="keyword">uint_xlen_t</span> rs1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; XLEN; index++)</span><br><span class="line">    count += (rs1 &gt;&gt; index) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>及 Spike 中，<code>pcnt</code> 指令的實作：</p><figure class="highlight c"><figcaption><span>riscv-isa-sim/riscv/insns/pcnt.h </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require_extension(<span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">reg_t</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; xlen; i++)</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &amp; (RS1 &gt;&gt; i)) x++;</span><br><span class="line">WRITE_RD(sext_xlen(x));</span><br></pre></td></tr></table></figure><p>實作很簡單，每次迴圈 right shift <code>rs1</code> <code>i</code> 個 bits 並與 <code>1</code> 做 <code>AND</code>，若為 <code>true</code> 就將 <code>count</code> 加 <code>1</code>，最後回傳的 <code>count</code> 就是 <code>1 bits</code> 個數。</p><hr><p><code>trans_pcnt()</code> 實作了 <code>pcnt</code> 指令對應的 <code>TCG ops</code>。QEMU 在執行時，會將 <code>target instructions</code> (e.g. RISC-V instructions) 轉譯成 <code>TCG ops</code>，而 <code>TCG ops</code> 則會再轉譯為 <code>host instructions</code> (e.g. x86 instruction)。</p><figure class="highlight plain"><figcaption><span>QEMU dynamic instructions translation</span></figcaption><table><tr><td class="code"><pre><span class="line">+---------------------+      +---------+      +-------------------+</span><br><span class="line">| Target Instructions | ---&gt; | TCG ops | ---&gt; | Host instructions |</span><br><span class="line">+---------------------+      +---------+      +-------------------+</span><br><span class="line">     (e.g. RISC-V)                                  (e.g. x86)</span><br></pre></td></tr></table></figure><p>關於 <code>TCG</code> 的說明，可以參考 QEMU 的 documentations：<a href="https://github.com/qemu/qemu/blob/master/docs/devel/tcg.rst" target="_blank" rel="noopener">Translator Internals</a>、<a href="https://github.com/qemu/qemu/blob/master/tcg/README" target="_blank" rel="noopener">TCG README</a>。</p><p>新增一檔案：<code>./target/riscv/insn_trans/trans_rvb.inc.c</code> 來定義 <code>B Extension</code> 指令的實作 (當然，目前只有 <code>pcnt</code> 指令)：</p><figure class="highlight c"><figcaption><span>./target/riscv/insn_trans/trans_rvb.inc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RISC-V translation routines for the RVB Standard Extension.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">trans_pcnt</span><span class="params">(DisasContext *ctx, arg_pcnt *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;rd != <span class="number">0</span>) &#123;</span><br><span class="line">        TCGv t0 = tcg_temp_new();</span><br><span class="line">        gen_get_gpr(t0, a-&gt;rs1);</span><br><span class="line">        gen_helper_pcnt(cpu_gpr[a-&gt;rd], t0);</span><br><span class="line">        tcg_temp_free(t0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由於對 <code>x0</code> (<code>zero register</code>) 的寫入都會被忽略，因此首先判斷 <code>rd</code> 是否為 <code>0</code>，若為 <code>0</code> 則不做任何的事情。</p><p>再來宣告一 TCG variable：<code>t0</code>，並透過 <code>gen_get_gpr()</code> 將 <code>rs1</code> 暫存器的值 (如 <code>pcnt_example</code> 中 <code>pcnt s0, s0</code> 指令，<code>rs1</code> 即為 <code>s0</code>，也就是 <code>x8</code>)，載入到 <code>t0</code>。</p><p>這邊還呼叫了我們所定義幫我們處理 <code>pcnt</code> 計算 <code>1 bits</code> 個數的 <code>pcnt</code> helper function：<code>gen_helper_pcnt()</code>。該 helper function 會在計算完後，將最後的結果存至 <code>rd</code> (i.e. <code>cpu_gpr[a-&gt;rd]</code>) 暫存器中。</p><p>最後別忘了要釋放之前所宣告的 TCG variable：<code>t0</code>。</p><p>P.S. 其實這邊可以更簡單的直接將 <code>cpu_gpr[a-&gt;rs1]</code> 傳入，省略 TCG variable：<code>t0</code> 的宣告：</p><figure class="highlight c"><figcaption><span>./target/riscv/insn_trans/trans_rvb.inc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RISC-V translation routines for the RVB Standard Extension.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">trans_pcnt</span><span class="params">(DisasContext *ctx, arg_pcnt *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;rd != <span class="number">0</span>) &#123;</span><br><span class="line">        gen_helper_pcnt(cpu_gpr[a-&gt;rd], cpu_gpr[a-&gt;rs1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pcnt</code> 的 helper function 定義如下：</p><figure class="highlight c"><figcaption><span>./target/riscv/helper.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bitmanip Extension */</span></span><br><span class="line">DEF_HELPER_1(pcnt, tl, tl)</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>./target/riscv/bitmanip_helper.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RISC-V Bitmanip Extension Helpers for QEMU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"qemu/osdep.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cpu.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"exec/exec-all.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"exec/helper-proto.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">target_ulong <span class="title">HELPER</span><span class="params">(pcnt)</span><span class="params">(target_ulong rs1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target_ulong count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TARGET_LONG_BITS; i++) &#123;</span><br><span class="line">        count += (rs1 &gt;&gt; i) &amp; <span class="number">1</span>;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上就是實作先前在 <code>B Extension</code> spec. 及 Spike 中所看到的 <code>1 bits</code> 個數計算方式。由於 <code>pcnt</code> helper function 只需接收 <code>rs1</code> 暫存器的值，並回傳最後 <code>1 bits</code> 個數的結果，因此，我們定義 <code>pcnt</code> 的 helper function 為接收一 <code>target_ulong</code> 型態的 <code>rs1</code> 並回傳 <code>target_ulong</code> 型態的 <code>1 bits</code> 個數結果。</p><p>最後別忘了將我們新增的 <code>bitmanip_helper.o</code> 加入 compile objects 列表：</p><figure class="highlight plain"><figcaption><span>./target/riscv/Makefile.objs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-y +&#x3D; translate.o op_helper.o cpu_helper.o cpu.o csr.o fpu_helper.o bitmanip_helper.o gdbstub.o</span><br></pre></td></tr></table></figure><hr><p>重新編譯 QEMU，再次執行 <code>pcnt_example</code>：</p><pre><code>.&#x2F;qemu&#x2F;riscv64-linux-user&#x2F;qemu-riscv64 pcnt_example</code></pre><pre><code>num &#x3D; 187# of set bits &#x3D; 6</code></pre><p>這次 QEMU 就可以正確的 decode 並執行 <code>pcnt</code> 指令了。</p><hr><p>在 QEMU 中新增指令的流程大致就如同本文所介紹，不過由於 <code>pcnt</code> 指令只是單純的 bit operation 指令，沒有像 <code>csr</code> 相關指令會涉及 <code>CPURISCVState</code> 的更新，以及像 <code>jal</code> 指令會涉及 <code>DisasContext</code> 的判斷，因此實作起來相對簡單。若欲讓 QEMU 支援不論是 <code>B Extension</code> 或是 <code>V Extension</code> 的其他指令，就是得好好 K spec. 並一個一個新增了。</p><p>另外最近剛好 C-Sky Microsystems 的 <code>LIU Zhiwei &amp;lt;zhiwei_liu@c-sky.com&amp;gt;</code> 在實作 <code>V Extension</code> 的 configure instructions：<code>vsetvl</code> 及 <code>vsetvli</code>，比起本文所介紹之 <code>B Extension</code> 的 <code>pcnt</code> 指令要來得複雜得多，<a href="https://github.com/patchew-project/qemu/commit/04f8d9c87bf88fabd1221f8758187ba1fa5628f0" target="_blank" rel="noopener">patches</a> 仍在被 reviewed 中，也可以做為參考。</p><p>本文所對 QEMU 做的修正，可以參考此 <a href="https://github.com/frankchang0125/qemu/commit/3ca50fb830ab3f2b9a1b806e2240ea5bff9dfabf" target="_blank" rel="noopener">commit</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;⚠️ 本文所使用的 QEMU 版本為：&lt;code&gt;v4.2.0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在之前的文章中 (&lt;a href=&quot;/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1&quot;&gt;Part 1.&lt;/a&gt;, &lt;a href=&quot;/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2&quot;&gt;Part 2.&lt;/a&gt;) 我們提到了如何使用 &lt;code&gt;Decodetree&lt;/code&gt; 來定義指令的 decoder。本篇文章就實際使用 &lt;code&gt;Decodetree&lt;/code&gt; 來定義一個 QEMU RISC-V 目前尚未支援的指令 - &lt;code&gt;B(itmanip) Extension&lt;/code&gt; 中的 &lt;code&gt;pcnt&lt;/code&gt; 指令，並實做其行為。&lt;/p&gt;
    
    </summary>
    
    
      <category term="QEMU" scheme="https://0xc0de.tw/categories/QEMU/"/>
    
      <category term="RISC-V" scheme="https://0xc0de.tw/categories/QEMU/RISC-V/"/>
    
    
      <category term="QEMU" scheme="https://0xc0de.tw/tags/QEMU/"/>
    
      <category term="RISC-V" scheme="https://0xc0de.tw/tags/RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>QEMU Decodetree 語法介紹 (Part 2.)</title>
    <link href="https://0xc0de.tw/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/"/>
    <id>https://0xc0de.tw/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/</id>
    <published>2020-02-01T06:57:43.000Z</published>
    <updated>2020-04-28T14:23:10.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⚠️ 本文所使用的 QEMU 版本為：<code>v4.2.0</code></p></blockquote><p>延續 <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/" title="Part 1.">Part 1.</a> 一文，本文將繼續介紹 <code>Decodetree</code> 中的 <code>Patterns</code> 及 <code>Pattern Groups</code> 語法。</p><a id="more"></a><hr><h1 id="Patterns"><a class="header-anchor" href="#Patterns"></a>Patterns</h1><p><code>Pattern</code> 實際定義了一個指令的 decode 方式。<code>Decodetree</code> 會根據 <code>Patterns</code> 的定義，來動態產生出對應的 <code>switch-case</code> decode 判斷式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pat_def      :&#x3D; identifier ( pat_elt )+</span><br><span class="line">pat_elt      :&#x3D; fixedbit_elt | field_elt | field_ref | args_ref | fmt_ref | const_elt</span><br><span class="line">fmt_ref      :&#x3D; &#39;@&#39; identifier</span><br><span class="line">const_elt    :&#x3D; identifier &#39;&#x3D;&#39; number</span><br></pre></td></tr></table></figure><p>其語法由使用者所定義的 <code>identifier</code>，隨後緊接著一個以上的 <code>pat_elt</code>。</p><ul><li><code>identifier</code> 可由開發者自訂，如：<code>addl_r</code>、<code>addli</code> … 等。</li><li><code>pat_elt</code> 則可以採用以下不同的語法：<ul><li><code>fixedbit_elt</code> 與在 <code>Format</code> 中 <code>fixedbit_elt</code> 的定義相同。</li><li><code>field_elt</code> 與在 <code>Format</code> 中 <code>field_elt</code> 的定義相同。</li><li><code>field_ref</code> 與在 <code>Format</code> 中 <code>field_ref</code> 的定義相同。</li><li><code>args_ref</code> 與在 <code>Format</code> 中 <code>args_ref</code> 的定義相同。</li><li><code>fmt_ref</code> 直接參考一個被定義過的 <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/#Formats">Format</a>。</li><li><code>const_elt</code> 可以直接指定某一個 <code>argument</code> 的值。</li></ul></li></ul><p>由於 <code>Pattern</code> 實際定義了一個指令的 decode 方式，因此<strong>所有的 bits</strong> 及 <strong>arguments (如果有參考 args_ref 的話)</strong>  都必須明確的被定義，如果在搭配了所有的 <code>pat_elt</code> 後還有未定義的 bits 或是 arguments 的話，<code>Decodetree</code> 便會報錯。</p><p>此外，<code>Pattern</code> 所產生出來的 decoder，最後還會呼叫對應的 <code>translator function</code>。</p><ul><li><code>translator function</code> 需開發者自行定義。</li></ul><h3 id="Examples"><a class="header-anchor" href="#Examples"></a>Examples</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addl_i   010000 ..... ..... .... 0000000 ..... @opi</span><br></pre></td></tr></table></figure><p>定義了 <code>addl_i</code> 這個指令的 <code>Pattern</code>，其中：</p><ul><li>insn[31:26] 為 <code>010000</code>。</li><li>insn[11:5] 為 <code>0000000</code>。</li><li>參考了 <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/#Examples-3">Part 1. Examples</a> 定義的 <code>@opi</code> <code>Format</code>。</li><li>由於 <code>Pattern</code> 的<strong>所有 bits</strong> 都必須明確的被定義，因此 <code>@opi</code> 必須包含其餘 <code>insn[25:12]</code> 及 <code>insn[4:0]</code> 的格式定義，否則 <code>Decodetree</code> 便會報錯。</li></ul><p>最後 <code>addl_i</code> 的 decoder 還會呼叫 <code>trans_addl_i()</code> 這個 <code>translator function</code>。</p><p>搭配之前介紹的 <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/#Fields">Fields</a>、<a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/#Argument-Sets">Argument Sets</a> 及 <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/#Formats">Formats</a>，讓我們再看幾個完整的例子應該會更清楚 <code>Decodetree</code> 是怎產生一個指令的 decoder 的。</p><hr><p>首先是 RISC-V 的 <code>lui</code> 及 <code>auipc</code> 指令：</p><img src="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/lui_auipc.png" class="" title="LUI &amp; AUIPC instruction formats"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Fields:</span><br><span class="line">%rd        7:5</span><br><span class="line"></span><br><span class="line"># immediates:</span><br><span class="line">%imm_u    12:s20                 !function&#x3D;ex_shift_12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Argument sets:</span><br><span class="line">&amp;u    imm rd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Formats:</span><br><span class="line">@u       ....................      ..... ....... &amp;u      imm&#x3D;%imm_u          %rd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Patterns</span><br><span class="line">lui      ....................       ..... 0110111 @u</span><br><span class="line">auipc    ....................       ..... 0010111 @u</span><br></pre></td></tr></table></figure><p>會產生以下 <code>lui</code> 及 <code>auipc</code> 的 decoder：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line">    <span class="keyword">int</span> rd;</span><br><span class="line">&#125; arg_u;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32_extract_u</span><span class="params">(DisasContext *ctx, arg_u *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;imm = ex_shift_12(ctx, sextract32(insn, <span class="number">12</span>, <span class="number">20</span>));</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">decode_insn32</span><span class="params">(DisasContext *ctx, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        arg_u f_u;</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    decode_insn32_extract_u(ctx, &amp;u.f_u, insn);</span><br><span class="line">    <span class="keyword">switch</span> (insn &amp; <span class="number">0x0000007f</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000017</span>:</span><br><span class="line">        <span class="comment">/* ........ ........ ........ .0010111 */</span></span><br><span class="line">        <span class="comment">/* ./insn32.decode:18 */</span></span><br><span class="line">        <span class="keyword">if</span> (trans_auipc(ctx, &amp;u.f_u)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000037</span>:</span><br><span class="line">        <span class="comment">/* ........ ........ ........ .0110111 */</span></span><br><span class="line">        <span class="comment">/* ./insn32.decode:17 */</span></span><br><span class="line">        <span class="keyword">if</span> (trans_lui(ctx, &amp;u.f_u)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顧到目前為止所介紹的：</p><ul><li><p><code>Argument Sets</code>：<code>&amp;u</code> 這個 <code>argument set</code> 包含了 <code>imm</code> 及 <code>rd</code> 這兩個 <code>arguments</code>。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line">    <span class="keyword">int</span> rd;</span><br><span class="line">&#125; arg_u;</span><br></pre></td></tr></table></figure></li><li><p><code>Fields</code>： <code>imm</code> 及 <code>rd</code>  分別位在 insn[31:12] 及 insn[11:7]，且 <code>imm</code> 為 <code>sign-extended</code>。最後在擷取出 <code>imm</code> 的值後，還會呼叫 <code>ex_shift_12()</code>。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;imm = ex_shift_12(ctx, sextract32(insn, <span class="number">12</span>, <span class="number">20</span>));</span><br><span class="line">a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Formats</code>：<code>@u</code> 定義了 RISC-V <code>U-type</code> 指令的格式</p><ul><li>參考了 <code>&amp;u</code> 這個 <code>Argument Set</code>，因此 decode function 會傳入 <code>arg_u</code> 作為參數。</li><li>insn[31:12] 參考了 <code>imm_u</code> 這個 <code>Field</code> (並重新命名為 <code>imm</code>)</li><li>insn[11:7] 參考了 <code>rd</code> 這個 <code>Field</code>。</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32_extract_u</span><span class="params">(DisasContext *ctx, arg_u *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;imm = ex_shift_12(ctx, sextract32(insn, <span class="number">12</span>, <span class="number">20</span>));</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Patterns</code>：</p><ul><li><code>lui</code> 的 <code>opcode</code> (insn[6:0]) 為 <code>0010111</code>，也就是 <code>0x17</code>，在產生出來的 <code>switch-case</code> 中可以看到其對應的 <code>case</code>。</li><li><code>lui</code> 的 decoder 最後呼叫了 <code>trans_lui()</code>，並傳入 <code>DisasContext</code> 及經由 <code>decode_insn32_extract_u()</code> 所解析出來的 <code>arg_u</code>。</li><li><code>auipc</code> 的 <code>opcode</code> (insn[6:0]) 為 <code>0110111</code>，也就是 <code>0x37</code>，在產生出來的 <code>switch-case</code> 中可以看到其對應的 <code>case</code>。</li><li><code>auipc</code> 的 decoder 最後呼叫了 <code>trans_auipc()</code>，並傳入 <code>DisasContext</code> 及經由 <code>decode_insn32_extract_u()</code> 所解析出來的 <code>arg_u</code>。</li><li>P.S. 這邊由於 <code>Decodetree</code> 發現 <code>lui</code> 及 <code>auipc</code> 可以共用 <code>decode_insn32_extract_u()</code>，因此將其提到了 <code>switch-case</code> 之外。</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">decode_insn32</span><span class="params">(DisasContext *ctx, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        arg_u f_u;</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    decode_insn32_extract_u(ctx, &amp;u.f_u, insn);</span><br><span class="line">    <span class="keyword">switch</span> (insn &amp; <span class="number">0x0000007f</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000017</span>:</span><br><span class="line">        <span class="comment">/* ........ ........ ........ .0010111 */</span></span><br><span class="line">        <span class="comment">/* ./insn32.decode:18 */</span></span><br><span class="line">        <span class="keyword">if</span> (trans_auipc(ctx, &amp;u.f_u)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000037</span>:</span><br><span class="line">        <span class="comment">/* ........ ........ ........ .0110111 */</span></span><br><span class="line">        <span class="comment">/* ./insn32.decode:17 */</span></span><br><span class="line">        <span class="keyword">if</span> (trans_lui(ctx, &amp;u.f_u)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們另外可以發現，<code>Pattern</code> + <code>Format</code> 把所有的 32-bits 都給了明確的定義：</p><ul><li><code>Pattern</code> 定義了 <code>opcode</code> (insn[6:0])。</li><li><code>Format</code> 參考了 <code>imm</code> (insn[31:12]) 及 <code>rd</code> (insn[11:7])。</li></ul><p>如果有任何未明確定義的 bits 的話，<code>Decodetree</code> 便會報錯，例如如果我們將 <code>lui</code> 的 <code>opcode</code> 最高 2 個 bits (insn[6:5]) 由 <code>01</code> 改成 <code>..</code>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lui      ....................       ..... ..10111 @u</span><br></pre></td></tr></table></figure><p><code>Decodetree</code> 在解析時，便會報錯：</p><blockquote><p>./insn32.decode:17: error: (‘bits left unspecified (0x00000060)’,)</p></blockquote><p><code>Decodetree</code> 提醒我們，insn[6:5] (<code>0x00000060</code>) 尚未給出明確定義，並會顯示出其錯誤的行數。</p><p><code>trans_lui()</code> 和 <code>trans_auipc()</code> 被定義在 <code>target/riscv/insn_trans/trans_rvi.inc.c</code>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">trans_lui</span><span class="params">(DisasContext *ctx, arg_lui *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;rd != <span class="number">0</span>) &#123;</span><br><span class="line">        tcg_gen_movi_tl(cpu_gpr[a-&gt;rd], a-&gt;imm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">trans_auipc</span><span class="params">(DisasContext *ctx, arg_auipc *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;rd != <span class="number">0</span>) &#123;</span><br><span class="line">        tcg_gen_movi_tl(cpu_gpr[a-&gt;rd], a-&gt;imm + ctx-&gt;base.pc_next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>trans_*()</code> 負責實際指令的 business logics 及產生對應的 <code>TCG codes</code>。</p></li></ul><hr><p>如同先前所介紹，<code>Patterns</code> 的 <code>pat_elt</code> 也可以採用 <code>field_elt</code> 語法，如 RISC-V 的 <code>fence</code> 指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fence    ---- pred:4 succ:4 ----- 000 ----- 0001111</span><br></pre></td></tr></table></figure><ul><li>insn[27:24] 為 <code>pred</code>。</li><li>insn[23:20] 為 <code>succ</code>。</li><li>insn[14:12] 固定為 <code>000</code>。</li><li>insn[6:0] 為 <code>opcode</code> (<code>0001111</code>)。</li><li>沒有參考任何的 <code>Format</code>。</li><li>剩下的 insn[31:28]、insn[19:15]、insn[11:7] 被宣告為 <code>-</code>，因此就算沒有被明確定義也沒有關係。</li></ul><p>所生成 <code>fence</code> 的 decoder 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pred;</span><br><span class="line">    <span class="keyword">int</span> succ;</span><br><span class="line">&#125; arg_decode_insn320;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32_extract_decode_insn32_Fmt_0</span><span class="params">(DisasContext *ctx, arg_decode_insn320 *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;pred = extract32(insn, <span class="number">24</span>, <span class="number">4</span>);</span><br><span class="line">    a-&gt;succ = extract32(insn, <span class="number">20</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">decode_insn32</span><span class="params">(DisasContext *ctx, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        arg_decode_insn320 f_decode_insn320;</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    decode_insn32_extract_decode_insn32_Fmt_0(ctx, &amp;u.f_decode_insn320, insn);</span><br><span class="line">    <span class="keyword">switch</span> (insn &amp; <span class="number">0x0000707f</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x0000000f</span>:</span><br><span class="line">        <span class="comment">/* ........ ........ .000.... .0001111 */</span></span><br><span class="line">        <span class="comment">/* ./insn32.decode:2 */</span></span><br><span class="line">        <span class="keyword">if</span> (trans_fence(ctx, &amp;u.f_decode_insn320)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，雖然這次我們沒有參考任何的 <code>Argument Set</code>，但 <code>Decodetree</code> 還是替我們生成了一個包含 <code>pred</code> 和 <code>succ</code> 的 <code>arg_decode_insn320</code> 。</p><p><code>trans_fence()</code> 同樣是被定義在 <code>./target/riscv/insn_trans/trans_rvi.inc.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">trans_fence</span><span class="params">(DisasContext *ctx, arg_fence *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* FENCE is a full memory barrier. */</span></span><br><span class="line">    tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Pattern-Groups"><a class="header-anchor" href="#Pattern-Groups"></a>Pattern Groups</h1><p><code>Pattern Groups</code> 由一個以上的 <code>Patterns</code> 所組成，其主要差別是不同 <code>Patterns</code> 之間的 bits 可以 overlap。當同組中有多個 <code>Patterns</code> 時，會依據該組中各 <code>Pattern</code> 的宣告順序依序判斷目前的指令是否符合其定義。除此之外，當符合的 <code>Pattern</code> 其 <code>trans_*()</code> 回傳值為 <code>false</code> 時，也會被視為<strong>不相符</strong>，而繼續判斷該組中的下一個 <code>Pattern</code>。因此 <code>Pattern Groups</code> 非常適合將多個相似格式的指令給組成同一個 <code>Pattern Group</code>。</p><p>原文說明如下：</p><blockquote><p>Unlike ungrouped patterns, grouped patterns are allowed to overlap. Conflicts are resolved by selecting the patterns in order.  If all of the <code>fixedbits</code> for a pattern match, its translate function will be called.  If the translate function returns <code>false</code>, then subsequent patterns within the group will be matched.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group    :&#x3D; &#39;&#123;&#39; ( pat_def | group )+ &#39;&#125;&#39;</span><br></pre></td></tr></table></figure><p>各 <code>Pattern Group</code> 以 <code>{</code> 開頭，並以 <code>}</code> 結尾，且允許 <code>nested pattern groups</code> 的存在，其他語法皆與 <code>Pattern</code> 相同。</p><h3 id="Examples-2"><a class="header-anchor" href="#Examples-2"></a>Examples</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    nop   000010 ----- ----- 0000 001001 0 00000</span><br><span class="line">    copy  000010 00000 r1:5  0000 001001 0 rt:5</span><br><span class="line">  &#125;</span><br><span class="line">  or      000010 rt2:5 r1:5  cf:4 001001 0 rt:5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>會產生以下的 decoder：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (insn &amp; <span class="number">0xfc000fe0</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x08000240</span>:</span><br><span class="line">    <span class="comment">/* 000010.. ........ ....0010 010..... */</span></span><br><span class="line">    <span class="keyword">if</span> ((insn &amp; <span class="number">0x0000f000</span>) == <span class="number">0x00000000</span>) &#123;</span><br><span class="line">        <span class="comment">/* 000010.. ........ 00000010 010..... */</span></span><br><span class="line">        <span class="keyword">if</span> ((insn &amp; <span class="number">0x0000001f</span>) == <span class="number">0x00000000</span>) &#123;</span><br><span class="line">            <span class="comment">/* 000010.. ........ 00000010 01000000 */</span></span><br><span class="line">            extract_decode_Fmt_0(&amp;u.f_decode0, insn);</span><br><span class="line">            <span class="keyword">if</span> (trans_nop(ctx, &amp;u.f_decode0)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 這邊沒有直接回傳 false，讓 switch-case 繼續往下執行</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((insn &amp; <span class="number">0x03e00000</span>) == <span class="number">0x00000000</span>) &#123;</span><br><span class="line">          <span class="comment">/* 00001000 000..... 00000010 010..... */</span></span><br><span class="line">          extract_decode_Fmt_1(&amp;u.f_decode1, insn);</span><br><span class="line">          <span class="keyword">if</span> (trans_copy(ctx, &amp;u.f_decode1)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">　<span class="comment">// 這邊沒有直接回傳 false，讓 switch-case 繼續往下執行</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  extract_decode_Fmt_2(&amp;u.f_decode2, insn);</span><br><span class="line">  <span class="keyword">if</span> (trans_or(ctx, &amp;u.f_decode2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當指令的值符合 <code>nop</code> 及 <code>copy</code> 這個內層 <code>Pattern Group</code> 時，會先判斷該指令是否符合 <code>nop</code> 指令的定義，且 <code>trans_nop()</code> 的回傳值為 <code>true</code>。否則的話，就會繼續判斷是否符合同組中的 <code>copy</code> 指令。若都不符，就會再判斷是否符合外層 <code>Pattern Group</code> 的 <code>or</code> 指令。若仍不符，才會回傳 <code>false</code> 表示 decode 失敗。</p><p>與單純使用 <code>Pattern</code> 最大不同的是，當一 <code>Pattern</code> 的 <code>trans_*()</code> 回傳值為 <code>false</code> 時，不會直接回傳 <code>false</code> (代表 decode 失敗)，而是會接續著判斷後續的 <code>Patterns</code> 是否相符。</p><hr><p>RISC-V Compressed-Extension 中的 <code>c.ebreak</code>、<code>c.jalr</code>、及 <code>c.add</code> 指令，由於這三個指令的格式非常相似，因此非常適合使用 <code>Pattern Group</code> 來定義：</p><img src="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/risc_v_c_insn.png" class="" title="RISC-V Compressed-Extension instruction formats"><p>RISC-V spec. 中定義：</p><p><code>C.EBREAK</code> shares the <code>opcode</code> with the <code>C.ADD</code> instruction, but with <code>rd</code> and <code>rs2</code> both <code>zero</code>, thus can also use the <code>CR</code> format.</p><p><code>C.JALR</code> is only valid when <code>rs1≠x0</code>; the code point with <code>rs1=x0</code> corresponds to the <code>C.EBREAK</code> instruction.</p><p><code>C.ADD</code> is only valid when <code>rs2≠x0</code>; the code points with <code>rs2=x0</code> correspond to the <code>C.JALR</code> and <code>C.EBREAK</code> instructions. The code points with <code>rs2̸=x0</code> and <code>rd=x0</code> are <code>HINTs</code>.</p><p><code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 三個指令：</p><ul><li>insn[15:13]、insn[12]、insn[1:0] 的值皆相同。</li><li>當 insn[11:7] 且 insn[6:2] 的值皆為 <code>0</code> (<code>rs1=0</code> 且 <code>rs2=0</code>) 時為 <code>c.ebreak</code> 指令。</li><li>當只有 insn[11:7] 的值為 <code>0</code> (<code>rs1=0</code> 且 <code>rs2≠0</code>) 時為 <code>c.jalr</code> 指令。</li><li>否則為 <code>c.add</code> 指令 (<code>rs1≠x0</code> 且 <code>rs2≠0</code>)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Fields</span><br><span class="line">%rd        7:5</span><br><span class="line">%rs2_5     2:5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Argument Sets</span><br><span class="line">&amp;r         rd rs1 rs2   !extern</span><br><span class="line">&amp;i         imm rs1 rd   !extern</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Formats</span><br><span class="line">@cr        ....  ..... .....  .. &amp;r      rs2&#x3D;%rs2_5       rs1&#x3D;%rd     %rd</span><br><span class="line">@c_jalr    ... . .....  ..... .. &amp;i      imm&#x3D;0 rs1&#x3D;%rd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Pattern Groups</span><br><span class="line">&#123;</span><br><span class="line">  ebreak          100 1  00000  00000 10</span><br><span class="line">  jalr            100 1  .....  00000 10 @c_jalr rd&#x3D;1  # C.JALR</span><br><span class="line">  add             100 1  .....  ..... 10 @cr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所生成的 decoder 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn16_extract_c_jalr</span><span class="params">(DisasContext *ctx, arg_i *a, <span class="keyword">uint16_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;imm = <span class="number">0</span>; <span class="comment">// 在 c_jalr 的 Format 中指定 imm 的值為 0</span></span><br><span class="line">    a-&gt;rs1 = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn16_extract_cr</span><span class="params">(DisasContext *ctx, arg_r *a, <span class="keyword">uint16_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;rs2 = extract32(insn, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    a-&gt;rs1 = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn16_extract_decode_insn16_Fmt_2</span><span class="params">(DisasContext *ctx, arg_decode_insn162 *a, <span class="keyword">uint16_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">decode_insn16</span><span class="params">(DisasContext *ctx, <span class="keyword">uint16_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        arg_decode_insn162 f_decode_insn162;</span><br><span class="line">        arg_i f_i;</span><br><span class="line">        arg_r f_r;</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (insn &amp; <span class="number">0x0000f003</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00009002</span>:</span><br><span class="line">        <span class="comment">/* 1001.... ......10 */</span></span><br><span class="line">        <span class="keyword">if</span> ((insn &amp; <span class="number">0x00000ffc</span>) == <span class="number">0x00000000</span>) &#123;</span><br><span class="line">            <span class="comment">/* 10010000 00000010 */</span></span><br><span class="line">            <span class="comment">/* ./insn16.decode:20 */</span></span><br><span class="line">            decode_insn16_extract_decode_insn16_Fmt_2(ctx, &amp;u.f_decode_insn162, insn);</span><br><span class="line">            <span class="keyword">if</span> (trans_ebreak(ctx, &amp;u.f_decode_insn162)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 這邊沒有直接回傳 false，讓 switch-case 繼續往下執行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((insn &amp; <span class="number">0x0000007c</span>) == <span class="number">0x00000000</span>) &#123;</span><br><span class="line">            <span class="comment">/* 1001.... .0000010 */</span></span><br><span class="line">            <span class="comment">/* ./insn16.decode:21 */</span></span><br><span class="line">            decode_insn16_extract_c_jalr(ctx, &amp;u.f_i, insn);</span><br><span class="line">            u.f_i.rd = <span class="number">1</span>; <span class="comment">// 在 jalr 的 Pattern 中指定 rd 的值為 0。</span></span><br><span class="line">            <span class="keyword">if</span> (trans_jalr(ctx, &amp;u.f_i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 這邊沒有直接回傳 false，讓 switch-case 繼續往下執行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* ./insn16.decode:22 */</span></span><br><span class="line">        decode_insn16_extract_cr(ctx, &amp;u.f_r, insn);</span><br><span class="line">        <span class="keyword">if</span> (trans_add(ctx, &amp;u.f_r)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當指令格式符合 <code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 的 <code>Pattern Group</code> 時，會依序判斷該指令是否符合 <code>c.ebreak</code>、<code>c.jalr</code>、<code>c.add</code> 的定義以及其對應的 <code>trans_*()</code>。</p><p>另外值得一提的是，在 <code>c_jalr</code> <code>Format</code> 和 <code>jalr</code> <code>Pattern</code> 中有分別指定其 <code>imm</code> 及 <code>rd</code> 的值為 <code>0</code>，所生成的 codes 也會分別在對應的地方將該值設為 <code>0</code> (見 codes 註解說明)。</p><hr><p>以上就是 <code>Decodetree</code> 的語法說明。透過 <code>Decodetree</code>，我們不用再像以前以樣寫一大包的 <code>switch-case</code> 來 decode 指令。將不同類型的指令寫至不同的 decode 檔，不僅方便維護，閱讀起來也更為容易。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;⚠️ 本文所使用的 QEMU 版本為：&lt;code&gt;v4.2.0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;延續 &lt;a href=&quot;/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/&quot; title=&quot;Part 1.&quot;&gt;Part 1.&lt;/a&gt; 一文，本文將繼續介紹 &lt;code&gt;Decodetree&lt;/code&gt; 中的 &lt;code&gt;Patterns&lt;/code&gt; 及 &lt;code&gt;Pattern Groups&lt;/code&gt; 語法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="QEMU" scheme="https://0xc0de.tw/categories/QEMU/"/>
    
      <category term="RISC-V" scheme="https://0xc0de.tw/categories/QEMU/RISC-V/"/>
    
    
      <category term="QEMU" scheme="https://0xc0de.tw/tags/QEMU/"/>
    
      <category term="RISC-V" scheme="https://0xc0de.tw/tags/RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>QEMU Decodetree 語法介紹 (Part 1.)</title>
    <link href="https://0xc0de.tw/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/"/>
    <id>https://0xc0de.tw/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/</id>
    <published>2020-01-31T13:53:40.000Z</published>
    <updated>2020-04-28T14:23:10.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⚠️ 本文所使用的 QEMU 版本為：<code>v4.2.0</code></p></blockquote><p>QEMU 在 decode 指令的時候，需要呼叫各平台所定義的 instruction decoders 來解析指令。如在 ARM 平台下，就定義了：<code>disas_arm_insn()</code>、<code>disas_thumb_insn()</code> 及 <code>disas_thumb2_insn()</code> 等來分別負責 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。</p><p>而 <code>Decodetree</code> 則是由 <code>Bastian Koppelmann</code> 於 2017 年在 porting RISC-V QEMU 的時候所提出來的機制 (詳見：<a href="https://lists.gnu.org/archive/html/qemu-devel/2017-07/msg07735.html" target="_blank" rel="noopener">討論串 1</a>、<a href="https://lists.gnu.org/archive/html/qemu-devel/2017-10/msg05046.html" target="_blank" rel="noopener">討論串 2</a>)。主因是過往的 instruction decoders (如：ARM) 都是採用一大包的 <code>switch-case</code> 來做判斷。不僅難閱讀，也難以維護。</p><p>因此 <code>Bastian Koppelmann</code> 就提出了 <code>Decodetree</code> 的機制，開發者只需要透過 <code>Decodetree</code> 的語法定義各個指令的格式，便可交由 <code>Decodetree</code> 來動態生成對應包含 <code>switch-case</code> 的 instruction decoder <code>.c</code> 檔。</p><a id="more"></a><p><code>Decodetree</code> 特別適合像 RISC-V 這種具有<strong>固定指令格式</strong>的 ISA<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><ul><li>因為各欄位都在固定的位置，(如 RISC-V 的 <code>opcode</code> 都是固定在 <code>bits[6..0]</code> 的位置)，各指令可重複使用的定義相較於其他的 ISA 來得多。</li></ul><img src="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/riscv_insn_format.png" class="" title="RISC-V instruction formats"><p><code>Decodetree</code> 其實是由 Python script (<code>./scripts/decodetree.py</code>) 所撰寫的。其規格說明文件可以參考：<code>./docs/devel/decodetree.rst</code>，裡面有詳細定義了其語法的格式。QEMU 在編譯時，會呼叫 <code>Decodetree</code>，根據各平台所定義的 decode 檔，動態生成對應的 decoder。</p><ul><li><p>如 RISC-V 的 instruction decoders 就是被定義在：<code>./target/riscv/*.decode</code> 中。其 <code>Makefile.obj</code> 就有如下的宣告：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">DECODETREE &#x3D; $(SRC_PATH)&#x2F;scripts&#x2F;decodetree.py</span><br><span class="line"></span><br><span class="line">decode32-y &#x3D; $(SRC_PATH)&#x2F;target&#x2F;riscv&#x2F;insn32.decode</span><br><span class="line">decode32-$(TARGET_RISCV64) +&#x3D; $(SRC_PATH)&#x2F;target&#x2F;riscv&#x2F;insn32-64.decode</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">target&#x2F;riscv&#x2F;decode_insn32.inc.c: $(decode32-y) $(DECODETREE)</span><br><span class="line">$(call quiet-command, \</span><br><span class="line">  $(PYTHON) $(DECODETREE) -o $@ --static-decode decode_insn32 \</span><br><span class="line">          $(decode32-y), &quot;GEN&quot;, $(TARGET_DIR)$@)</span><br></pre></td></tr></table></figure><p>(實際參數說明請見 <a href="#decodetree-%E5%8F%83%E6%95%B8">decodetree 參數</a>)</p></li></ul><p><code>Decodetree</code> 的語法共分為：<a href="#Fields">Fields</a>、<a href="#Argument-Sets">Argument Sets</a>、<a href="#Formats">Formats</a>、<a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/#Patterns">Patterns</a>、<a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/#Pattern-Groups">Pattern Groups</a> 五部分。本文將介紹如何透過 <code>Decodetree</code> 的語法，來動態生成一個指令的 decoder。</p><hr><h1 id="Fields"><a class="header-anchor" href="#Fields"></a>Fields</h1><p><code>Field</code> 定義如何取出一指令中，各<strong>欄位</strong> (eg: <code>rd</code>, <code>rs1</code>, <code>rs2</code>, <code>imm</code>) 的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">field_def     :&#x3D; &#39;%&#39; identifier ( unnamed_field )* ( !function&#x3D;identifier )?</span><br><span class="line">unnamed_field :&#x3D; number &#39;:&#39; ( &#39;s&#39; ) number</span><br></pre></td></tr></table></figure><p>其語法由 <code>%</code> 開頭，隨後緊接著一個 <code>identifier</code> 及零個或多個 <code>unamed_field</code>，並可再加上可選的 <code>!function</code>。</p><ul><li><code>identifier</code> 可由開發者自訂，如：<code>rd</code>、<code>imm</code>… 等。</li><li><code>unamed_field</code> 定義了該欄位的所在位元。第一個數字定義了該欄位的 <code>least-significant bit position</code>，第二個數字則定義了該欄位的<code>位元長度</code>。另外可加上可選的 <code>s</code> 字元來標明在取出該欄位後，是否需要做 <code>sign-extended</code>。<ul><li>Eg：<code>%rd  7:5</code> 代表 <code>rd</code> 佔了指令中 bits 7 ~ bits 11 的位置 (insn[11:7])，共 5 bits。</li></ul></li><li><code>!function</code> 定義在擷取出該欄位的值後，所會再呼叫的 function。</li></ul><p><code>Field</code> (32-bits 指令) 最後會生成對應的 <code>extract32()</code> 及 <code>sextract32()</code> 程式碼<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，以用來取得指令中各欄位的值：</p><h3 id="Examples"><a class="header-anchor" href="#Examples"></a>Examples</h3><table><thead><tr><th>Input</th><th>Generated code</th></tr></thead><tbody><tr><td>%disp 0:s16</td><td>sextract(i, 0, 16)</td></tr><tr><td>%imm9 16:6 10:3</td><td>extract(i, 16, 6) &lt;&lt; 3 | extract(i, 10, 3)</td></tr><tr><td>%disp12 0:s1 1:1 2:10</td><td>sextract(i, 0, 1) &lt;&lt; 11 | extract(i, 1, 1) &lt;&lt; 10 | extract(i, 2, 10)</td></tr><tr><td>%shimm8 5:s8 13:1 !function=expand_shimm8</td><td>expand_shimm8(sextract(i, 5, 8) &lt;&lt; 1 | extract(i, 13, 1))</td></tr></tbody></table><p>以 RISC-V 的 <code>U-type</code> 指令為例：</p><img src="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/riscv_u_type_insn.png" class="" title="RISC-V U-type instruction"><p>其中，<code>imm</code> 佔 <code>insn[31:12]</code>，<code>rd</code> 佔 <code>insn[11:7]</code>，且 <code>imm</code> 需要做 <code>sign-extended</code>  後 <code>左移 12 位</code> (<code>20-bit immediate is shifted left by 12 bits to form U immediates</code>)。因此，如果我們要定義 RISC-V 的 <code>U-type</code> 指令，則可以宣告成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%rd       7:5</span><br><span class="line">%imm_u    12:s20                 !function&#x3D;ex_shift_12</span><br></pre></td></tr></table></figure><p>最後會生成如下的程式碼：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32_extract_u</span><span class="params">(DisasContext *ctx, arg_u *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;imm = ex_shift_12(ctx, sextract32(insn, <span class="number">12</span>, <span class="number">20</span>));</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(P.S. <code>static void decode_insn32_extract_u()</code> 是由 <a href="#Formats">Format</a> 定義所生成的，而 <code>arg_u *a</code> 則是由 <a href="#Argument-Sets">Argument Set</a> 定義所生成的，將會在後面的部分再做說明)</p><p>可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;imm = ex_shift_12(ctx, sextract32(insn, <span class="number">12</span>, <span class="number">20</span>));</span><br><span class="line">a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>a-&gt;imm</code> 是由 <code>insn[31:12]</code> 所取得並做 <code>sign-extended</code>，且會再呼叫 <code>ex_shift_12()</code> 來 <code>左移 12 個 bits</code>。</p><ul><li>P.S. RISC-V 的 <code>ex_shift_12()</code> 是透過定義在<code>./target/riscv/translate.c</code> 中 <code>EX_SH</code> 這個 macro 所展開的：</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EX_SH(amount) \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ex_shift_#<span class="meta">#amount(DisasContext *ctx, int imm) \</span></span><br><span class="line">    &#123;                                         \</span><br><span class="line">        <span class="keyword">return</span> imm &lt;&lt; amount;                 \</span><br><span class="line">    &#125;</span><br><span class="line">EX_SH(<span class="number">1</span>)</span><br><span class="line">EX_SH(<span class="number">2</span>)</span><br><span class="line">EX_SH(<span class="number">3</span>)</span><br><span class="line">EX_SH(<span class="number">4</span>)</span><br><span class="line">EX_SH(<span class="number">12</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>a-&gt;rd</code> 是由 <code>insn[11:7]</code> 所取得。</p></li></ul><p>此外，在 <code>Decodetree</code> 的 spec. 中也有提到，我們可以透過只定義 <code>!function</code> 來直接呼叫該 function。在這種情況下，只有 <code>DisasContext</code> 會被傳入該 function。</p><p>One may use <code>!function</code> with zero <code>unnamed_fields</code>.  This case is called<br>a <strong>parameter</strong>, and the named function is only passed the <code>DisasContext</code><br>and returns an integral value extracted from there.</p><p>如 ARM Thumb <code>./target/arm/t16.decode</code> 就有定義：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Set S if the instruction is outside of an IT block.</span><br><span class="line">%s               !function&#x3D;t16_setflags</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">disas_t16_extract_addsub_2i</span><span class="params">(DisasContext *ctx, arg_s_rri_rot *a, <span class="keyword">uint16_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;imm = extract32(insn, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    a-&gt;rn = extract32(insn, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    a-&gt;s = t16_setflags(ctx); <span class="comment">// 呼叫 t16_setflags()，並傳入 DisasContext</span></span><br><span class="line">    a-&gt;rot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未包含任何 <code>unnamed_fields</code> 或 <code>!function</code> 的 <code>Field</code> 會被視為錯誤。</p><p>A field with no <code>unnamed_fields</code> and no <code>!function</code> is in error.</p><hr><h1 id="Argument-Sets"><a class="header-anchor" href="#Argument-Sets"></a>Argument Sets</h1><p><code>Argument Set</code> 定義用來保存從指令中所擷取出來各欄位的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args_def    :&#x3D; &#39;&amp;&#39; identifier ( args_elt )+ ( !extern )?</span><br><span class="line">args_elt    :&#x3D; identifier</span><br></pre></td></tr></table></figure><p>其語法由 <code>&amp;</code> 開頭，隨後緊接著一個或多個的 <code>identifier</code> ，並可再加上可選的 <code>!extern</code> 。</p><ul><li><code>identifier</code> 可由開發者自訂，如：<code>regs</code>、<code>loadstore</code>… 等。</li><li><code>!extern</code> 則表示是否在其他地方已經由其他的 decoder 定義過。如果加上的話，就<strong>不會</strong>再次生成對應的 <code>argument set struct</code>。</li></ul><h3 id="Examples-2"><a class="header-anchor" href="#Examples-2"></a>Examples</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ampreg3 ra rb rc</span><br></pre></td></tr></table></figure><p>會生成以下的 <code>argument set struct</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ra;</span><br><span class="line">    <span class="keyword">int</span> rb;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">&#125; arg_reg3;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;loadstore reg base offset</span><br></pre></td></tr></table></figure><p>則會生成以下的 <code>argument set struct</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> base;</span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">int</span> reg;</span><br><span class="line">&#125; arg_loadstore;</span><br></pre></td></tr></table></figure><hr><p>因此，以剛剛的 RISC-V <code>U-type</code> 指令為例，我們需要從指令中擷取 <code>imm</code> 及 <code>rd</code> 欄位的值，可以宣告其 <code>argument set</code> 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;u    imm rd</span><br></pre></td></tr></table></figure><p>最後會生成以下的 <code>argument set struct</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line">    <span class="keyword">int</span> rd;</span><br><span class="line">&#125; arg_u;</span><br></pre></td></tr></table></figure><p>此 <code>argument set struct</code> 會被傳入由 <code>Format</code> 定義所生成的 extract function：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32_extract_u</span><span class="params">(DisasContext *ctx, arg_u *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;imm = ex_shift_12(ctx, sextract32(insn, <span class="number">12</span>, <span class="number">20</span>));</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所傳入的<code>arg_u</code> 會保存從指令中擷取出的 <code>imm</code> 及 <code>rd</code> 欄位的值，待後續使用。</p><hr><h1 id="Formats"><a class="header-anchor" href="#Formats"></a>Formats</h1><p><code>Format</code> 定義了指令的格式 (如 RISC-V 中的 <code>R</code>、<code>I</code>、<code>S</code>、<code>B</code>、<code>U</code>、<code>J-type</code>)，並會生成對應的 decode function。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt_def      :&#x3D; &#39;@&#39; identifier ( fmt_elt )+</span><br><span class="line">fmt_elt      :&#x3D; fixedbit_elt | field_elt | field_ref | args_ref</span><br><span class="line">fixedbit_elt :&#x3D; [01.-]+</span><br><span class="line">field_elt    :&#x3D; identifier &#39;:&#39; &#39;s&#39;? number</span><br><span class="line">field_ref    :&#x3D; &#39;%&#39; identifier | identifier &#39;&#x3D;&#39; &#39;%&#39; identifier</span><br><span class="line">args_ref     :&#x3D; &#39;&amp;&#39; identifier</span><br></pre></td></tr></table></figure><p>其語法由 <code>@</code> 開頭，隨後緊接著一個 <code>identifier</code> 及一個以上的 <code>fmt_elt</code>。</p><ul><li><code>identifier</code> 可由開發者自訂，如：<code>opr</code>、<code>opi</code>… 等。</li><li><code>fmt_elt</code> 則可以採用以下不同的語法：<ul><li><p><code>fixedbit_elt</code> 包含一個或多個  <code>0</code>、<code>1</code>、<code>.</code>、<code>-</code>，每一個代表指令中的 1 個 bit。</p><ul><li><code>.</code> 代表該 bit 可以用 <code>0</code> 或是 <code>1</code> 來表示。</li><li><code>-</code> 代表該 bit 完全被忽略。</li></ul></li><li><p><code>field_elt</code> 可以用 <a href="#Fields">Field</a> 的語法來宣告。</p><ul><li>Eg：<code>ra:5</code>、<code>rb:5</code>、<code>lit:8</code></li></ul></li><li><p><code>field_ref</code> 有下列兩種格式 (以下範例參考上文所定義之 <a href="#Fields">Field</a>)：</p><ul><li><p><code>'%' identifier</code>：直接參考一個被定義過的 <code>Field</code>。</p><ul><li><p>如：<code>%rd</code>，會生成：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>identifier '=' '%' identifier</code>：直接參考一個被定義過的 <code>Field</code>，但透過第一個 <code>identifier</code> 來重新命名其所對應的 <code>argument</code> 名稱。此方式可以用來指定不同的 <code>argument</code> 名稱來參考至同一個 <code>Field</code>。</p><ul><li><p>如：<code>my_rd=%rd</code>，會生成：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;my_rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>); <span class="comment">// rd 被重新命名為 my_rd</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>args_ref</code> 指定所傳入 decode function 的 <code>Argument Set</code>。若沒有指定 <code>args_ref</code> 的話，<code>Decodetree</code> 會根據 <code>field_elt</code> 或 <code>field_ref</code> 自動生成一個 <code>Argument Set</code>。此外，一個 <code>Format</code> 最多只能包含一個 <code>args_ref</code>。</p></li></ul></li></ul><p>當 <code>fixedbit_elt</code> 或 <code>field_ref</code> 被定義時，該 <code>Foramt</code> 的所有的 bits 都必須被定義 (可透過 <code>fixedbit_elt</code> 或 <code>.</code> 來定義各個 bits，<code>空格</code>會被忽略)。</p><h3 id="Examples-3"><a class="header-anchor" href="#Examples-3"></a>Examples</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@opi    ...... ra:5 lit:8    1 ....... rc:5</span><br></pre></td></tr></table></figure><p>定義了 <code>op1</code> 這個 <code>Format</code>，其中：</p><ul><li>insn[31:26] 可為 <code>0</code> 或 <code>1</code>。</li><li>insn[25:21] 為 <code>ra</code>。</li><li>insn[20:13] 為 <code>lit</code>。</li><li>insn[12] 固定為 <code>1</code>。</li><li>insn[11:5] 可為 <code>0</code> 或 <code>1</code>。</li><li>insn[4:0] 為 <code>rc</code>。</li></ul><p>此 <code>Format</code> 會生成以下的 decode function：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lit;</span><br><span class="line">    <span class="keyword">int</span> ra;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">&#125; arg_decode_insn320;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32_extract_opi</span><span class="params">(DisasContext *ctx, arg_decode_insn320 *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;ra = extract32(insn, <span class="number">21</span>, <span class="number">5</span>);</span><br><span class="line">    a-&gt;lit = extract32(insn, <span class="number">13</span>, <span class="number">8</span>);</span><br><span class="line">    a-&gt;rc = extract32(insn, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由於我們沒有指定 <code>args_ref</code>，因此 <code>Decodetree</code> 根據了 <code>field_elt</code> 的定義，自動生成了 <code>arg_decode_insn320</code> 這個 <code>Argument Set</code>。</p><hr><p>以 RISC-V <code>I-type</code> 指令為例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Fields:</span><br><span class="line">%rs1       15:5</span><br><span class="line">%rd        7:5</span><br><span class="line"></span><br><span class="line"># immediates:</span><br><span class="line">%imm_i    20:s12</span><br><span class="line"></span><br><span class="line"># Argment sets:</span><br><span class="line">&amp;i    imm rs1 rd</span><br><span class="line"></span><br><span class="line">@i       ........ ........ ........ ........ &amp;i      imm&#x3D;%imm_i     %rs1 %rd</span><br></pre></td></tr></table></figure><p>定義了 <code>i</code> 這個 <code>Format</code>，其中：</p><ul><li>insn[31:20] 為 <code>imm</code>，且為 <code>sign-extended</code>。</li><li>insn[19:5] 為 <code>rs1</code>。</li><li>insn[11:7] 為 <code>rd</code>。</li></ul><p>此外，我們可以看到：</p><ul><li>此 <code>Format</code> 指定了 <code>Argument Set</code>：<code>&amp;i</code>。 <code>&amp;i</code> 中必須包含所有有用到的 <code>arguments</code> (也就是：<code>imm</code>、<code>rs1</code> 及 <code>rd</code>)</li><li><code>imm</code> 是透過重新命名的方式來參考 <code>%imm_i</code> 這個 <code>Field</code>。</li></ul><p>此範例會生成以下的 decode function：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line">    <span class="keyword">int</span> rd;</span><br><span class="line">    <span class="keyword">int</span> rs1;</span><br><span class="line">&#125; arg_i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32extract_i</span><span class="params">(DisasContext *ctx, arg_i *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;imm = sextract32(insn, <span class="number">20</span>, <span class="number">12</span>); <span class="comment">// imm_i 被重新命名為 imm</span></span><br><span class="line">    a-&gt;rs1 = extract32(insn, <span class="number">15</span>, <span class="number">5</span>);</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比於第一個範例，由於這次我們有指定 <code>args_ref</code>：<code>&amp;i</code>，因此對應的 <code>arg_i</code> 會被傳入 decode function。</p><hr><p>回到先前的 RISC-V <code>U-type</code> 指令，我們可以如同 <code>I-type</code> 指令定義其格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Fields:</span><br><span class="line">%rd        7:5</span><br><span class="line"></span><br><span class="line"># immediates:</span><br><span class="line">%imm_u    12:s20                 !function&#x3D;ex_shift_12</span><br><span class="line"></span><br><span class="line"># Argument sets:</span><br><span class="line">&amp;u    imm rd</span><br><span class="line"></span><br><span class="line">@u       ....................      ..... ....... &amp;u      imm&#x3D;%imm_u          %rd</span><br></pre></td></tr></table></figure><p>定義了 <code>u</code> 這個 <code>Format</code>，其中：</p><ul><li>insn[31:12] 為 <code>imm</code>，且為 <code>sign-extended</code>。</li><li>insn[11:7] 為 <code>rd</code>。</li></ul><p>會生成以下的 decode function：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line">    <span class="keyword">int</span> rd;</span><br><span class="line">&#125; arg_u;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode_insn32_extract_u</span><span class="params">(DisasContext *ctx, arg_u *a, <span class="keyword">uint32_t</span> insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;imm = ex_shift_12(ctx, sextract32(insn, <span class="number">12</span>, <span class="number">20</span>));</span><br><span class="line">    a-&gt;rd = extract32(insn, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們可以看到：</p><ul><li>此 <code>Format</code> 指定了 <code>Argument Set</code>：<code>&amp;u</code>。 <code>&amp;u</code> 中必須包含所有有用到的 <code>arguments</code> (也就是：<code>imm</code>、<code>rd</code>)</li><li><code>imm</code> 是透過重新命名的方式來參考 <code>%imm_u</code> 這個 <code>Field</code>。</li></ul><hr><p>以上就是 <code>Decodetree</code> 的 <a href="#Fields">Fields</a>、<a href="#Argument-Sets">Argument Sets</a> 及 <a href="#Formats">Formats</a> 語法的簡介。剩下的 <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/#Patterns">Patterns</a> 及 <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/#Pattern-Groups">Pattern Groups</a> 就留到 <a href="/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/" title="Part 2.">Part 2.</a> 再做介紹。</p><hr><h1 id="decodetree-參數"><a class="header-anchor" href="#decodetree-參數"></a>decodetree 參數</h1><ul><li><code>--translate</code>：translator function 的 prefix，預設為 <code>trans</code>。一旦指定後，translator function 的 scope 就不會再是 <code>static</code>。</li><li><code>--decode</code>：decode function 的 prefix，預設為 <code>decode</code>，且 scope 為 <code>static</code>。一旦指定後，decode function 的 scope 就不會再是 <code>static</code>。</li><li><code>--static-decode</code>：如同 <code>--decode</code>，不過 decode function 的 scope 仍維持為 <code>static</code>。</li><li><code>-o</code> / <code>--output</code>：指定生成的 decoder <code>.c</code> 檔路徑。</li><li><code>-w</code> / <code>--insnwidth</code>：指令長度，eg：<code>32</code> or <code>16</code>，預設為 <code>32</code>。</li><li><code>--varinsnwidth</code>：指令為不定長度。</li><li><code>最後一個參數</code>為輸入的 decode 檔路徑。</li></ul><p>執行範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;decodetree.py -o target&#x2F;riscv&#x2F;decode_insn16.inc.c --static-decode decode_insn16 \</span><br><span class="line">    -w 16 .&#x2F;insn16.decode</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>ARM 其實在 <code>Decodetree</code> 引進後，也有部分的 instructions 改採用 <code>Decodetree</code> 來動態生成對應的 instruction decoders</p><ul><li>如 Thumb 指令：<code>./target/arm/t32.decode</code> 及 <code>./target/arm/t16.decode</code>。</li></ul> <a href="#fnref1" class="footnote-backref">↩︎</a></li><li id="fn2" class="footnote-item"><p><code>extract32()</code> 及 <code>sextract32()</code> 被定義在 <code>include/qemu/bitops.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * extract32:</span></span><br><span class="line"><span class="comment"> * @value: the value to extract the bit field from</span></span><br><span class="line"><span class="comment"> * @start: the lowest bit in the bit field (numbered from 0)</span></span><br><span class="line"><span class="comment"> * @length: the length of the bit field</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Extract from the 32 bit input @value the bit field specified by the</span></span><br><span class="line"><span class="comment"> * @start and @length parameters, and return it. The bit field must</span></span><br><span class="line"><span class="comment"> * lie entirely within the 32 bit word. It is valid to request that</span></span><br><span class="line"><span class="comment"> * all 32 bits are returned (ie @length 32 and @start 0).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: the value of the bit field extracted from the input value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">extract32</span><span class="params">(<span class="keyword">uint32_t</span> value, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(start &gt;= <span class="number">0</span> &amp;&amp; length &gt; <span class="number">0</span> &amp;&amp; length &lt;= <span class="number">32</span> - start);</span><br><span class="line">    <span class="keyword">return</span> (value &gt;&gt; start) &amp; (~<span class="number">0U</span> &gt;&gt; (<span class="number">32</span> - length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sextract32:</span></span><br><span class="line"><span class="comment"> * @value: the value to extract the bit field from</span></span><br><span class="line"><span class="comment"> * @start: the lowest bit in the bit field (numbered from 0)</span></span><br><span class="line"><span class="comment"> * @length: the length of the bit field</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Extract from the 32 bit input @value the bit field specified by the</span></span><br><span class="line"><span class="comment"> * @start and @length parameters, and return it, sign extended to</span></span><br><span class="line"><span class="comment"> * an int32_t (ie with the most significant bit of the field propagated</span></span><br><span class="line"><span class="comment"> * to all the upper bits of the return value). The bit field must lie</span></span><br><span class="line"><span class="comment"> * entirely within the 32 bit word. It is valid to request that</span></span><br><span class="line"><span class="comment"> * all 32 bits are returned (ie @length 32 and @start 0).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: the sign extended value of the bit field extracted from the</span></span><br><span class="line"><span class="comment"> * input value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span> <span class="title">sextract32</span><span class="params">(<span class="keyword">uint32_t</span> value, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(start &gt;= <span class="number">0</span> &amp;&amp; length &gt; <span class="number">0</span> &amp;&amp; length &lt;= <span class="number">32</span> - start);</span><br><span class="line">    <span class="comment">/* Note that this implementation relies on right shift of signed</span></span><br><span class="line"><span class="comment">     * integers being an arithmetic shift.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int32_t</span>)(value &lt;&lt; (<span class="number">32</span> - length - start))) &gt;&gt; (<span class="number">32</span> - length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <a href="#fnref2" class="footnote-backref">↩︎</a></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;⚠️ 本文所使用的 QEMU 版本為：&lt;code&gt;v4.2.0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;QEMU 在 decode 指令的時候，需要呼叫各平台所定義的 instruction decoders 來解析指令。如在 ARM 平台下，就定義了：&lt;code&gt;disas_arm_insn()&lt;/code&gt;、&lt;code&gt;disas_thumb_insn()&lt;/code&gt; 及 &lt;code&gt;disas_thumb2_insn()&lt;/code&gt; 等來分別負責 ARM 32-bits 指令、ARM Thumb 指令及 ARM Thumb2 指令的解析。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;Decodetree&lt;/code&gt; 則是由 &lt;code&gt;Bastian Koppelmann&lt;/code&gt; 於 2017 年在 porting RISC-V QEMU 的時候所提出來的機制 (詳見：&lt;a href=&quot;https://lists.gnu.org/archive/html/qemu-devel/2017-07/msg07735.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;討論串 1&lt;/a&gt;、&lt;a href=&quot;https://lists.gnu.org/archive/html/qemu-devel/2017-10/msg05046.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;討論串 2&lt;/a&gt;)。主因是過往的 instruction decoders (如：ARM) 都是採用一大包的 &lt;code&gt;switch-case&lt;/code&gt; 來做判斷。不僅難閱讀，也難以維護。&lt;/p&gt;
&lt;p&gt;因此 &lt;code&gt;Bastian Koppelmann&lt;/code&gt; 就提出了 &lt;code&gt;Decodetree&lt;/code&gt; 的機制，開發者只需要透過 &lt;code&gt;Decodetree&lt;/code&gt; 的語法定義各個指令的格式，便可交由 &lt;code&gt;Decodetree&lt;/code&gt; 來動態生成對應包含 &lt;code&gt;switch-case&lt;/code&gt; 的 instruction decoder &lt;code&gt;.c&lt;/code&gt; 檔。&lt;/p&gt;
    
    </summary>
    
    
      <category term="QEMU" scheme="https://0xc0de.tw/categories/QEMU/"/>
    
      <category term="RISC-V" scheme="https://0xc0de.tw/categories/QEMU/RISC-V/"/>
    
    
      <category term="QEMU" scheme="https://0xc0de.tw/tags/QEMU/"/>
    
      <category term="RISC-V" scheme="https://0xc0de.tw/tags/RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel: ARRAY_SIZE()</title>
    <link href="https://0xc0de.tw/Linux-Kernel-ARRAY-SIZE/"/>
    <id>https://0xc0de.tw/Linux-Kernel-ARRAY-SIZE/</id>
    <published>2012-10-15T03:37:40.000Z</published>
    <updated>2020-04-28T14:23:10.268Z</updated>
    
    <content type="html"><![CDATA[<p>通常我們在 C 語言中取得陣列的元數個數可以透過下列的方式來計算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> arr_size = ARRAY_SIZE(arr);</span><br></pre></td></tr></table></figure><p>但如同 Jserv 大大在 <a href="http://blog.linux.org.tw/~jserv/archives/001888.html" target="_blank" rel="noopener">這篇文章</a> 中所提到：<strong>ARRAY_SIZE()</strong> 這樣的 macro 其實是陷阱重重…</p><a id="more"></a><p>因為 macro 本身沒辦法做型態檢查，只是單純的將值帶入並展開，而在 C 中我們常常會將指標和陣列混著使用。因此若是我們將指向該陣列的指標傳入，就會得到錯誤的計算結果。</p><p>如下面的程式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE(arr)     (sizeof(arr) / sizeof(arr[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> *a_ptr = a;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ARRAY_SIZE(a));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ARRAY_SIZE(a_ptr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若傳入陣列 <em>a</em>，則結果會正確顯示 size 大小為 <strong>10</strong>，但若傳入的是指向陣列 <em>a</em> 的指標 <em>a_ptr</em>，則因為指標的在 32 位元作業系統上大小為 <strong>4 bytes</strong> (4 / 4) 的結果則會變成 <strong>1</strong>，而並不是我們所要的答案 <strong>10</strong>。</p><p>當然只要我們小心使用，這樣的問題其實是可以避免的。但我們常常有可能會將陣列透過指標的方式傳入某個 function 中，這樣的情況下我們就有可能會將指標誤用成陣列傳入 <strong>ARRAY_SIZE()</strong> 而得到錯誤的結果。當程式成長到一定的複雜度後，類似的bug就很有可能被忽略。</p><p>因此 Linux 在定義 <strong>ARRAY_SIZE()</strong> 時除了透過上述的方式來取得陣列元數個數外，還另外加上了<strong>型態檢查</strong>，以確保使用者所傳入的參數必須為陣列而非指標 (Linux中的 <strong>ARRAY_SIZE()</strong> 是被定義在：<em>include/linux/kernel.h</em>)，其定義如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))</span></span><br></pre></td></tr></table></figure><p>其中在最尾端額外加了 <strong>__must_be_array()</strong> 的回傳值。<strong>__must_be_array()</strong> 這個 macro 是用來判斷所傳入的參數是否為一陣列 (定義在：<em>include/linux/compiler-gcc.h</em>)，其定義如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &amp;a[0] degrades to a pointer: a different type from an array */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __must_be_array(a) BUILD_BUG_ON_ZERO(__same_type((a), &amp;(a)[0]))</span></span><br></pre></td></tr></table></figure><p>在這邊 <strong>__must_be_array()</strong> 對所傳入的參數 <strong>a</strong> 做了一次<strong>降級 (degrade)</strong>，並將其當作第二個參數傳入 <strong>__same_type()</strong> 這個 macro。在這邊做降級的目的就是為了讓<strong>陣列</strong>轉成一個<strong>指標</strong>，但若所傳入的參數 <em>a</em> 是個<strong>不應傳入的指標</strong>，則這樣的降級轉換後的結果仍會是<strong>相同的原指標</strong>。</p><p><strong>__same_type()</strong> 的回傳值則會傳入 <strong>BUILD_BUG_ON_ZERO()</strong><br>(<strong>BUILD_BUG_ON_ZERO()</strong> 的說明可以參考：<a href="/Linux-Kernel-BUILD-BUG-ON-ZERO-BUILD-BUG-ON-NULL/" title="BUILD_BUG_ON_ZERO() &#x2F; BUILD_BUG_ON_NULL()">BUILD_BUG_ON_ZERO() &#x2F; BUILD_BUG_ON_NULL()</a>)。</p><p><strong>__same_type()</strong> 的定義則如下 (定義在：<em>include/linux/compiler.h</em>)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Are two types/vars the same type (ignoring qualifiers)? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __same_type</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在這邊我們可以看到 <strong>__same_type()</strong> 呼叫了 GCC 的 built-in function：<strong>__builtin_types_compatible_p()</strong>：<br>(<strong>__builtin_types_compatible_p()</strong> 的定義可以參考 <a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Other-Builtins.html#Other-Builtins" target="_blank" rel="noopener">GCC manual</a> 的說明)；<strong>__builtin_types_compatible_p()</strong> 的定義可以參考 <a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Other-Builtins.html#Other-Builtins" target="_blank" rel="noopener">GCC manual</a> 的說明</p><blockquote><p>You can use the built-in function __builtin_types_compatible_p to determine whether two types are the same.<br>This built-in function returns 1 if the unqualified versions of the types type1 and type2 (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions.<br>This built-in function ignores top level qualifiers (e.g., const, volatile). For example, int is equivalent to const int.<br>The type int[] and int[5] are compatible. On the other hand, int and char * are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, short * is not similar to short **. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible.<br>An enum type is not considered to be compatible with another enum type even if both are compatible with the same integer type; this is what the C standard specifies. For example, enum {foo, bar} is not similar to enum {hot, dog}.<br>You would typically use this function in code whose execution varies depending on the arguments’ types. For example:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo(x)                                                  \</span></span><br><span class="line">  (&#123;                                                           \</span><br><span class="line">    typeof (x) tmp = (x);                                       \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_types_compatible_p (typeof (x), <span class="keyword">long</span> <span class="keyword">double</span>)) \</span><br><span class="line">      tmp = foo_long_double (tmp);                              \</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_types_compatible_p (typeof (x), <span class="keyword">double</span>)) \</span><br><span class="line">      tmp = foo_double (tmp);                                   \</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_types_compatible_p (typeof (x), <span class="keyword">float</span>))  \</span><br><span class="line">      tmp = foo_float (tmp);                                    \</span><br><span class="line">    <span class="keyword">else</span>                                                        \</span><br><span class="line">      <span class="built_in">abort</span> ();                                                 \</span><br><span class="line">    tmp;                                                        \</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>Note: This construct is only available for C.</p></blockquote><p>也就是說 <strong>__builtin_types_compatible_p()</strong> 會檢查所傳入的型態：<em>type_1</em> 和 <em>type_2</em> 是否相同：</p><ul><li>若 <em>type_1</em> 和 <em>type_2</em> 的型態相同，則會回傳 <strong>1</strong>。</li><li>若 <em>type_1</em> 和 <em>type_2</em> 的型態不同，則會回傳 <strong>0</strong>。</li></ul><p>此外，為了取得參數的型態，這邊還另外用到了另一個 GCC 的 extension：<strong>typeof()</strong>。<strong>typeof()</strong> 可以取得所傳入參數的型態，因此我們可以透過 <strong>typeof()</strong> 來宣告一個與所傳入參數一模一樣的新變數：<br>(<strong>typeof()</strong> 的定義同樣可以參考 <a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Typeof.html#Typeof" target="_blank" rel="noopener">GCC manual</a> 的說明)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE(arr)     (sizeof(arr) / sizeof(arr[0]))</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        typeof(a) b;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ARRAY_SIZE(a));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ARRAY_SIZE(b));</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此我們宣告一個與陣列 <em>a</em> 型態一模一樣的陣列 <em>b</em>，因此透過 <strong>ARRAY_SIZE()</strong> 計算陣列元數個數的結果都會是 <strong>10</strong>。</p><hr><p>回到 <strong>__same_type()</strong>：</p><p>透過 <strong>__builtin_types_compatible_p()</strong> 和 <strong>typeof()</strong>，我們就可以知道所傳入的兩個參數型態是否相同：</p><ul><li><p>如果相同 (傳入 <strong>ARRAY_SIZE()</strong> 的參數為一不應傳入的指標)，則 <strong>__builtin_types_compatible_p()</strong> 就會回傳 <strong>1</strong>，再傳入 <strong>BUILD_BUG_ON_ZERO()</strong> 後就會造成編譯錯誤。</p></li><li><p>但如果不同 (傳入 <strong>ARRAY_SIZE()</strong> 的參數為一正確的陣列)，則 <strong>__builtin_types_compatible_p()</strong> 就會回傳 <strong>0</strong>，再傳入 <strong>BUILD_BUG_ON_ZERO()</strong> 後得到的結果為 <strong>0</strong>，加回 <strong>ARRAY_SIZE()</strong> 後並不會影響其原先結果。</p></li></ul><p>透過這樣的方式，我們便可在 compile-time 的時候就發現所傳入 <strong>ARRAY_SIZE()</strong> 的參數是否為一錯誤的指標，並可在編譯時期加以修正…</p><p>此外 Jserv 大大 <a href="http://blog.linux.org.tw/~jserv/archives/001888.html" target="_blank" rel="noopener">那篇文章</a> 下面的回應也有人提出了其他不同的 <a href="http://heaven.branda.to/~thinker/GinGin_CGI.py/show_id_doc/236" target="_blank" rel="noopener">作法</a>。雖然其原意是為了要避免使用 GCC extension 的，但最後發現原來 <strong>typeof()</strong> 也是一個 GCC extension，不過作法同樣可以作為參考。</p><hr><p>Extra References:</p><ul><li><a href="http://blog.linux.org.tw/~jserv/archives/001876.html" target="_blank" rel="noopener">sizeof 在語言層面的陷阱</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常我們在 C 語言中取得陣列的元數個數可以透過下列的方式來計算：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arr_size = ARRAY_SIZE(arr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但如同 Jserv 大大在 &lt;a href=&quot;http://blog.linux.org.tw/~jserv/archives/001888.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;這篇文章&lt;/a&gt; 中所提到：&lt;strong&gt;ARRAY_SIZE()&lt;/strong&gt; 這樣的 macro 其實是陷阱重重…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux Kernel" scheme="https://0xc0de.tw/categories/Linux-Kernel/"/>
    
      <category term="Tricks" scheme="https://0xc0de.tw/categories/Linux-Kernel/Tricks/"/>
    
    
      <category term="C" scheme="https://0xc0de.tw/tags/C/"/>
    
      <category term="C++" scheme="https://0xc0de.tw/tags/C/"/>
    
      <category term="Linux Kernel" scheme="https://0xc0de.tw/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel: BUILD_BUG_ON_ZERO() / BUILD_BUG_ON_NULL()</title>
    <link href="https://0xc0de.tw/Linux-Kernel-BUILD-BUG-ON-ZERO-BUILD-BUG-ON-NULL/"/>
    <id>https://0xc0de.tw/Linux-Kernel-BUILD-BUG-ON-ZERO-BUILD-BUG-ON-NULL/</id>
    <published>2012-10-15T00:50:00.000Z</published>
    <updated>2020-04-28T14:23:10.252Z</updated>
    
    <content type="html"><![CDATA[<p>之前在 trace Linux Kernel source codes 時發現了兩個很特別的 macros：<strong>BUILD_BUG_ON_ZERO()</strong> 和 <strong>BUILD_BUG_ON_NULL()</strong><br>(定義在：<em>include/linux/kernel.h</em>)</p><p>它們的定義如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Force a compilation error if condition is true, but also produce a</span></span><br><span class="line"><span class="comment">   result (of value 0 and type size_t), so the expression can be used</span></span><br><span class="line"><span class="comment">   e.g. in a structure initializer (or where-ever else comma expressions</span></span><br><span class="line"><span class="comment">   aren't permitted). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUILD_BUG_ON_ZERO(e) (sizeof(struct &#123; int:-!!(e); &#125;))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct &#123; int:-!!(e); &#125;))</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>其中 <em>e</em> 是我們所傳入的判斷式，若判斷式為 <em>true</em>，則會造成 compile error。如此我們便可透過這個 macro 來判斷是否某些錯誤/不應發生的情況 (判斷式) 是否會發生，若會發生則可在 compile-time 的時候就顯示錯誤訊息。</p><p>一開始看不太懂這個 macro 的意義，上網查了資料後發現在 Stackoverflow 上有人做了很詳細的解釋：<a href="http://stackoverflow.com/questions/9229601/what-is-in-c-code" target="_blank" rel="noopener">What is 「:-!!」 in C code?</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(struct &#123; <span class="keyword">int</span>:-!!(e); &#125;)</span><br></pre></td></tr></table></figure><p>如同 Stackoverflow 上所解釋，這段 codes 可以拆成下面幾個片段來分析：</p><ul><li><p><strong>!!(e)</strong></p><p>將所傳入的 <em>e</em> 做兩次 negative，如此可以確保只要 <em>e</em> 不為 0 結果一定為 1，<em>e</em> 為 0 結果仍為 0。</p></li><li><p><strong>-!!(e)</strong></p><p>將剛剛的結果乘上 (-1)，因此只要 <em>e</em> 不為 0 結果就會是 -1，<em>e</em> 為 0 結果仍為 0。</p></li><li><p><strong>struct { int:-1!!(e) }</strong></p><p>宣告一個 structure，包含一個 int，這邊用到了 C 語言 bit-fields的技巧。<br>根據<a href="http://en.wikipedia.org/wiki/Bit_field" target="_blank" rel="noopener">維基百科 bit-fields</a> 的定義：</p><blockquote><p>A bit field is a common idiom used in computer programming to compactly store multiple logical values as a short series of bits where each of the single bits can be addressed separately.</p></blockquote><p>也就是說我們可以將資料以 bit 的形式儲存在某一個資料型態中，舉例來說：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b : <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> c : <span class="number">2</span>;</span><br><span class="line">&#125; flags;</span><br></pre></td></tr></table></figure><p>就宣告了 3 個 bit-fields：<em>a</em>, <em>b</em>, <em>c</em>。這 3 個 bit-fields 會包在同一個 <em>unsigned char</em> 資料型態 (8-bits) 中，其中 <em>a</em> 佔了 1 個bit，<em>b</em> 佔了 3 個 bits，<em>c</em> 佔了 2 個 bits，但整個 flags structure 還是會佔 8 個 bits (1 byte)，即使 bit-fields 並沒有佔滿整個 8 bits 空間。</p><p>此外，bit-fields 是無法使用 <strong>sizeof()</strong> 取得其 size 的，因此以下的 codes 將會產生：<strong>error: ‘sizeof’ applied to a bit-field</strong> 的錯誤訊息：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(flags.a));</span><br></pre></td></tr></table></figure><hr><p>回到原本的 <strong>struct { int:-1!!(e) }</strong>，我們可以得知：</p><p>若 <em>e</em> 不為 0，則 <strong>struct { int:-!!(e); }</strong> 會展開成：<strong>struct { int:-1; }</strong>。也就是會宣告一個 structure，包含 1 個佔 int (32 bits) 中，<strong>-1</strong> 個 bits 的 anonymous bit-field。當然，絕對不會有佔 <strong>-1</strong> 個 bits 的 bit-field 存在，因此這樣會導致在編譯時產生：<strong>error: negative width in bit-field ‘<anonymous>’</strong> 的錯誤訊息。</p><p>若 <em>e</em> 為 0，則 <strong>struct { int:-1!!(e); }</strong> 會展開成：<strong>struct { int:0; }</strong>。也就是宣告一個 structure，包含 1 個佔 int (32 bits) 中，<strong>0</strong> 個 bits 的 anonymous bit-field。<strong>0</strong> 個 bits 的 bit-field 並不會造成編譯出錯，事實上，宣告成 <strong>0</strong> 個 bits 的 bit-field 通常是用來將資料強制對齊至下一個word邊界 (force alignment at the next word boundary)，而且<strong>不會佔任何的空間!!</strong>。</p></li></ul><p>透過這樣的方式，只要傳入 <em><strong>BUILD_BUG_ON_ZERO(e)</strong></em> 的 <em>e</em> 不為 0，其就會造成 <strong>編譯出錯</strong>。</p><p>若傳入 <strong>BUILD_BUG_ON_ZERO(e)</strong> 的 <em>e</em> 為 0，則只會宣告一個 不佔任何空間的 structure。經過 <strong>sizeof()</strong> 計算後回傳 <strong>0</strong> 的值。</p><p>同樣的 <strong>BUILD_BUG_ON_NULL()</strong> 則是將上述的結果轉成 <strong>void</strong>，因此只要傳入 <strong>BUILD_BUG_ON_NULL(e)</strong> 的 <em>e</em> <strong>不為NULL</strong>，其就會造成 <strong>編譯出錯</strong>。</p><p>若傳入 <strong>BUILD_BUG_ON_NULL(e)</strong> 的 <em><strong>e 為 NULL</strong></em>，則只會宣告一個 <strong>不佔任何空間的 structure</strong>。經過 <strong>sizeof()</strong> 計算後仍為 <strong>0</strong>，再轉成一個<strong>指向位址 0 的 void</strong>。</p><p>而 Stackoverflow 上的回答也有提到，為何不直接使用 <strong>assert()</strong> 就好了？其答案也很清楚：</p><blockquote><p><strong>These macros implement a compile-time test, while assert() is a run-time test.</strong></p></blockquote><p>也就是說這樣的機制是可以在 compile-time 的時候就發現問題，而 <strong>assert()</strong> 則必須等到 run-time 的時候才能發現問題。不過也就是因為 <strong>BUILD_BUG_ON_ZERO()</strong> 和 <strong>BUILD_BUG_ON_NULL()</strong> 只能使用在 compile-time 就可以找到 bug 的情況下，因此若是判斷式中有任何必須等到 run-time 才能得知的結果，就會造成錯誤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUILD_BUG_ON_ZERO(e)    (sizeof(struct &#123; int:-!!(e); &#125;))</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        BUILD_BUG_ON_ZERO(a == <span class="number">2</span>);</span><br><span class="line">        BUILD_BUG_ON_ZERO(<span class="number">2</span> == <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次呼叫 <strong>BUILD_BUG_ON_ZERO()</strong> 由於傳入的判斷式中包含 run-time 才會得知其值的 <em>a</em>，因此會造成 compiler 錯誤的判斷，產生錯誤訊息：<strong>error: bit-field ‘<anonymous>’ width not an integer constant</strong>。但第二次呼叫 <strong>BUILD_BUG_ON_ZERO()</strong> 由於判斷式展開後皆可在 compile-time 的時候得知其結果，因此就不會產生錯誤訊息。</p><p>所以在使用 <strong>BUILD_BUG_ON_ZERO()</strong> 或是 <strong>BUILD_BUG_ON_NULL()</strong> 的時候還是要注意其使用時機…</p><hr><p>不得不說Linux內用了許多非常漂亮的技巧… 不但可以在 compile-time 的時候就將錯誤顯示出來，若判斷式 (錯誤/不應發生的情況) 不成立亦不會造成任何空間的浪費!!<br>(<strong>BUILD_BUG_ON_ZERO()</strong> 的實際用法可以參考 <a href="/Linux-Kernel-ARRAY-SIZE/" title="Linux Kernel: ARRAY_SIZE()">Linux Kernel: ARRAY_SIZE()</a> 一文)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在 trace Linux Kernel source codes 時發現了兩個很特別的 macros：&lt;strong&gt;BUILD_BUG_ON_ZERO()&lt;/strong&gt; 和 &lt;strong&gt;BUILD_BUG_ON_NULL()&lt;/strong&gt;&lt;br&gt;
(定義在：&lt;em&gt;include/linux/kernel.h&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;它們的定義如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Force a compilation error if condition is true, but also produce a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   result (of value 0 and type size_t), so the expression can be used&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   e.g. in a structure initializer (or where-ever else comma expressions&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   aren&#39;t permitted). */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; BUILD_BUG_ON_ZERO(e) (sizeof(struct &amp;#123; int:-!!(e); &amp;#125;))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct &amp;#123; int:-!!(e); &amp;#125;))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux Kernel" scheme="https://0xc0de.tw/categories/Linux-Kernel/"/>
    
      <category term="Tricks" scheme="https://0xc0de.tw/categories/Linux-Kernel/Tricks/"/>
    
    
      <category term="C" scheme="https://0xc0de.tw/tags/C/"/>
    
      <category term="C++" scheme="https://0xc0de.tw/tags/C/"/>
    
      <category term="Linux Kernel" scheme="https://0xc0de.tw/tags/Linux-Kernel/"/>
    
  </entry>
  
</feed>
